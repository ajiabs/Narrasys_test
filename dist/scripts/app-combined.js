'use strict';

// Declare the top level application module and its dependencies
angular.module('com.inthetelling.player', ['ngRoute', 'ngAnimate'])

// Configure routing
.config(function ($routeProvider, $locationProvider) {
	$routeProvider
		.when('/error', {
			controller: 'UIErrorController',
			templateUrl: 'templates/error.html'
		})
		.when('/episode/:epId', {
			controller: 'EpisodeController',
			template: '<div ng-include="episode.templateUrl">Loading Episode...</div>'
		})
		.when('/episode/:epId/:authKey', {
			controller: 'EpisodeController',
			template: '<div ng-include="episode.templateUrl">Loading Episode...</div>'
		})
		.otherwise({
				redirectTo: '/error'
			} // TODO I'd rather not rewrite the url if the user makes a typo; is there a better way to handle errors than a route redirect?
	);
	$locationProvider.html5Mode(false); // TODO sigh, can't get the server config working for this... thought we had it but IE still choked
})

// Configure x-domain resource whitelist
.config(function ($sceDelegateProvider) {
	$sceDelegateProvider.resourceUrlWhitelist([
		'self',
		/.*/,
		/^https?:\/\/danielbeck.net/,
		/^https?:\/\/platformuniv-p.edgesuite.net/
	]);
})

// Configure http headers
.config(function($httpProvider) {
	/*
	$httpProvider.defaults.headers.get = {
		'Authorization': 'Token token="c7624368e407355eb587500862322413"',
		'Content-Type': 'application/json'
	};
	*/
	$httpProvider.defaults.useXDomain = true;
	$httpProvider.defaults.withCredentials = true;
	delete $httpProvider.defaults.headers.common['X-Requested-With'];
});

/*
.run(['timelineSvc', '$window', function(timelineSvc, $window) {
	// fake a timeline provider (for testing and debugging)
	var setPlayhead = timelineSvc.registerProvider('mockTimeline', 1000);
	var position = 0;
	$window.setInterval(function(){
		position += 1;
		setPlayhead(position);
	}, 1000);
}]);
*/

'use strict';

// Auto-generated by grunt from contents of app/templates/*
// Direct edits to this file will be overwritten!!!
angular.module('com.inthetelling.player').run(['$templateCache', function($templateCache) {


  $templateCache.put('templates/contentpane.html',
    "<!-- \n" +
    "\tTODO:  item.styles is on both the ng-repeat and on the item. Harmless, but redundant.\n" +
    "\tNeed it on the ng-repeat for animations; check to see if we can remove it from the item\n" +
    "\t(will definitely require edits to item.css, maybe elsewhere?)\n" +
    "\n" +
    "-->\n" +
    "\n" +
    "<div class=\"content\" x-ng-class='{\"noSidebars\": noSidebars, \"hasLeftSidebar\": hasLeftSidebar, \"hasRightSidebar\": hasRightSidebar}'>\n" +
    "\t<h2 x-ng-if=\"pane == 'main'\" class=\"sceneTitle\">{{scene.title}}</h2>\n" +
    "\t<div x-ng-repeat=\"item in itemlist | itemList:showCurrent\" class=\"item-animate\" x-ng-class=\"item.styles\" data-force-item-template=\"{{forceItemTemplate}}\" x-itt-item=\"item\">\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/episode-default.html',
    "<div class=\"{{episode.styles}}\" x-ng-class=\"{isFramed: isFramed, isIPhone: isIPhone}\">\n" +
    "\t<div x-itt-video x-itt-magnetized class=\"vjs-wrapper\">\n" +
    "\t</div>\n" +
    "\t<div x-itt-toolbar>\n" +
    "\t</div>\n" +
    "\t<div class=\"episode episode{{episode.layout}}\">\n" +
    "\t\t<div x-ng-repeat=\"scene in scenes\" x-itt-scene=\"scene\"></div>\n" +
    "\t\t<div class=\"clear\"></div>\n" +
    "\t</div>\n" +
    "</div>\n" +
    "<div class=\"branding\">\n" +
    "\t<a class=\"itt\" href=\"http://inthetelling.com\">\n" +
    "\t\t<img src=\"images/itt.svg\" alt=\"In The Telling logo\">\n" +
    "\t</a>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/episode-eliterate.html',
    "<div class=\"{{episode.styles}} episode-eliterate\" x-ng-class=\"{isFramed: isFramed}\">\n" +
    "\t<div x-itt-video x-itt-magnetized class=\"vjs-wrapper\">\n" +
    "\t</div>\n" +
    "\t<div x-itt-toolbar>\n" +
    "\t</div>\n" +
    "\t<div class=\"eliterate-logo\">\n" +
    "\t\t<img src=\"images/eliterate-logo.svg\">\n" +
    "\t</div>\n" +
    "\t<div class=\"episode episode{{episode.layout}}\">\n" +
    "\t\t<div x-ng-repeat=\"scene in scenes\" x-itt-scene=\"scene\"></div>\n" +
    "\t\t<div class=\"clear\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"branding\">\n" +
    "\t\t<a class=\"eliterate\" href=\"http://www.mindwires.com\">\n" +
    "\t\t\t<img src=\"images/mindwires.svg\" alt=\"Mindwires logo\">\n" +
    "\t\t</a>\n" +
    "\t\t<a class=\"itt\" href=\"http://inthetelling.com\">\n" +
    "\t\t\t<img src=\"images/itt.svg\" alt=\"In The Telling logo\">\n" +
    "\t\t</a>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/error.html',
    "<div class=\"error\">\n" +
    "\t<h2>Error</h2>\n" +
    "\t<p>Something went wrong: {{errorMsg}}</p>\n" +
    "\t<span style=\"color:#FFF\">\n" +
    "\t\t<pre>{{errorDetails}}</pre>\n" +
    "\t</span>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/modal-image-default.html',
    "<div>\n" +
    "\t<img x-ng-src=\"{{item.source}}\" width=\"100%\">\n" +
    "</div>\n"
  );


  $templateCache.put('templates/modal-link-default.html',
    "<div x-ng-class=\"{isIDevice: item.isIDevice}\">\n" +
    "\t<div class=\"modalmenu\"><a href=\"{{item.source}}\" target=\"_blank\" class=\"escapelink\">(new window)</a>\n" +
    "\t</div>\n" +
    "\t<div class=\"modalIframeContainer\">\n" +
    "\t\t<iframe x-ng-src=\"{{item.source}}\"></iframe>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/scene-1col.html',
    "<div class=\"scene-1col {{scene.layout}} {{scene.styles}}\" x-ng-class='{\"currentScene\": scene.isActive, \"futureScene\": !scene.isActive && !scene.wasActive, \"pastScene\": !scene.isActive && scene.wasActive}'>\n" +
    "\t<div class=\"fillPane windowBg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowBg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"scene\">\n" +
    "\t\t<div class=\"pane videoContainer\">\n" +
    "\t\t\t<div class=\"fillPane video\">\n" +
    "\t\t\t\t<img class=\"aspectratiopreserver\" src=\"/images/aspectratiopreserver-16x9.gif\" />\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentMain stretchToViewportBottom\">\n" +
    "\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainBg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div x-itt-content-pane></div>\n" +
    "\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainFg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div x-itt-magnetized class=\"fillPane videoOverlay\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'videoOverlay'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"fillPane windowFg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowFg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/scene-2colL.html',
    "<div class=\"scene-2col scene-2colL {{scene.layout}} {{scene.styles}}\" x-ng-class='{\"currentScene\": scene.isActive, \"futureScene\": !scene.isActive && !scene.wasActive, \"pastScene\": !scene.isActive && scene.wasActive}'>\n" +
    "\t<div class=\"fillPane windowBg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowBg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"scene\">\n" +
    "\t\t<div class=\"pane videoContainer\">\n" +
    "\t\t\t<div class=\"fillPane video\">\n" +
    "\t\t\t\t<img class=\"aspectratiopreserver\" src=\"/images/aspectratiopreserver-16x9.gif\" />\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentMain stretchToViewportBottom\">\n" +
    "\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainBg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div>\n" +
    "\t\t\t\t<div class=\"matchVideoHeight\"></div>\n" +
    "\t\t\t\t<div data-pane=\"main\" data-content=\"{{scene.mainPaneContents}}\" x-itt-content-pane></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainFg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentAlt stretchToViewportBottom\">\n" +
    "\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'altBg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div>\n" +
    "\t\t\t\t<div class=\"matchVideoHeight\"></div>\n" +
    "\t\t\t\t<div data-pane=\"alt\" data-content=\"{{scene.altPaneContents}}\" x-itt-content-pane></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'altFg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div x-itt-magnetized class=\"fillPane videoOverlay\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'videoOverlay'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"fillPane windowFg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowFg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/scene-2colR.html',
    "<div class=\"scene-2col scene-2colR {{scene.layout}} {{scene.styles}}\" x-ng-class='{\"currentScene\": scene.isActive, \"futureScene\": !scene.isActive && !scene.wasActive, \"pastScene\": !scene.isActive && scene.wasActive}'>\n" +
    "\t<div class=\"fillPane windowBg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowBg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"scene\">\n" +
    "\t\t<div class=\"pane videoContainer\">\n" +
    "\t\t\t<div class=\"fillPane video\">\n" +
    "\t\t\t\t<img class=\"aspectratiopreserver\" src=\"/images/aspectratiopreserver-16x9.gif\" />\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentMain stretchToViewportBottom\">\n" +
    "\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainBg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div>\n" +
    "\t\t\t\t<div class=\"matchVideoHeight\"></div>\n" +
    "\t\t\t\t<div data-pane=\"main\" data-content=\"{{scene.mainPaneContents}}\" x-itt-content-pane></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainFg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentAlt stretchToViewportBottom\">\n" +
    "\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'altBg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div>\n" +
    "\t\t\t\t<div class=\"matchVideoHeight\"></div>\n" +
    "\t\t\t\t<div data-pane=\"alt\" data-content=\"{{scene.altPaneContents}}\" x-itt-content-pane></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'altFg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div x-itt-magnetized class=\"fillPane videoOverlay\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'videoOverlay'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"fillPane windowFg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowFg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/scene-animatetest.html',
    "<!-- \n" +
    "\n" +
    "This is an equivalent of scene-1col which allows animated transitions on Fg, Bg, and videoOverlay elements. \n" +
    "Most of the transitions don't play nicely with those items' positioning, however!  transitionFade is the only \n" +
    "currently trustworthy one.  \n" +
    "\n" +
    "TODO: decide whether to support that transtion (only)?\n" +
    "\n" +
    "TODO: does filter:{isActive:true} mean a performance hit?\n" +
    "\n" +
    "-->\n" +
    "\n" +
    "<div class=\"scene-1col {{scene.layout}} {{scene.styles}}\" x-ng-class='{\"currentScene\": scene.isActive, \"futureScene\": !scene.isActive && !scene.wasActive, \"pastScene\": !scene.isActive && scene.wasActive}'>\n" +
    "\t<div class=\"fillPane windowBg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowBg' | filter:{isActive:true}\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"scene\">\n" +
    "\t\t<div class=\"pane videoContainer\">\n" +
    "\t\t\t<div class=\"fillPane video\">\n" +
    "\t\t\t\t<img class=\"aspectratiopreserver\" src=\"/images/aspectratiopreserver-16x9.gif\" />\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentMain stretchToViewportBottom\">\n" +
    "\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainBg' | filter:{isActive:true}\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div x-itt-content-pane></div>\n" +
    "\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainFg' | filter:{isActive:true}\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div x-itt-magnetized class=\"fillPane videoOverlay\">\n" +
    "\t\t<div class=\"item-animate\" x-ng-repeat=\"item in scene.items | layout: 'videoOverlay' | filter:{isActive:true}\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"fillPane windowFg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowFg' | filter:{isActive:true}\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/scene-centered.html',
    "<div class=\"scene-centered {{scene.layout}} {{scene.styles}}\" x-ng-class='{\"currentScene\": scene.isActive, \"futureScene\": !scene.isActive && !scene.wasActive, \"pastScene\": !scene.isActive && scene.wasActive}'>\n" +
    "\t<div class=\"fillPane windowBg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowBg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"scene\">\n" +
    "\t\t<div class=\"pane videoContainer\">\n" +
    "\t\t\t<div class=\"fillPane video\">\n" +
    "\t\t\t\t<img class=\"aspectratiopreserver\" src=\"/images/aspectratiopreserver-16x9.gif\" />\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentMain stretchToViewportBottom\">\n" +
    "\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainBg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div data-no-sidebars=\"true\" data-show-current=\"true\" data-content=\"content\" x-itt-content-pane></div>\n" +
    "\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainFg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div x-itt-magnetized class=\"fillPane videoOverlay\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'videoOverlay'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"fillPane windowFg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowFg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/scene-cornerH.html',
    "<div class=\"scene-cornerH {{scene.layout}} {{scene.styles}}\" x-ng-class='{\"currentScene\": scene.isActive, \"futureScene\": !scene.isActive && !scene.wasActive, \"pastScene\": !scene.isActive && scene.wasActive}'>\n" +
    "\n" +
    "\t<div class=\"fillPane windowBg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowBg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"scene\">\n" +
    "\t\t<div class=\"pane videoContainer\">\n" +
    "\t\t\t<div class=\"fillPane video\">\n" +
    "\t\t\t\t<img class=\"aspectratiopreserver\" src=\"/images/aspectratiopreserver-16x9.gif\" />\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane smallPane contentMain matchVideoHeight\">\n" +
    "\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainBg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<br>\n" +
    "\t\t\t<div data-pane=\"main\" data-no-sidebars=\"true\" data-show-current=\"true\" data-content=\"{{scene.mainPaneContents}}\" x-itt-content-pane></div>\n" +
    "\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainFg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentAlt stretchToViewportBottom\">\n" +
    "\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'altBg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div data-pane=\"alt\" data-content=\"{{scene.altPaneContents}}\" x-itt-content-pane></div>\n" +
    "\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'altFg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div x-itt-magnetized class=\"fillPane videoOverlay\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'videoOverlay'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"fillPane windowFg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowFg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/scene-cornerV.html',
    "<div class=\"scene-cornerV {{scene.layout}} {{scene.styles}}\" x-ng-class='{\"currentScene\": scene.isActive, \"futureScene\": !scene.isActive && !scene.wasActive, \"pastScene\": !scene.isActive && scene.wasActive}'>\n" +
    "\t<div class=\"fillPane windowBg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowBg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"scene\">\n" +
    "\t\t<div class=\"scene-cornerV-column stretchToViewportBottom\">\n" +
    "\t\t\t<div class=\"pane videoContainer\">\n" +
    "\t\t\t\t<div class=\"fillPane video\">\n" +
    "\t\t\t\t\t<img class=\"aspectratiopreserver\" src=\"/images/aspectratiopreserver-16x9.gif\" />\n" +
    "\t\t\t\t</div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div class=\"pane smallPane contentMain stretchToViewportBottom\">\n" +
    "\t\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainBg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t\t</div>\n" +
    "\t\t\t\t<div data-pane=\"main\" data-no-sidebars=\"true\" data-show-current=\"true\" data-content=\"{{scene.mainPaneContents}}\" x-itt-content-pane></div>\n" +
    "\t\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'mainFg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t\t</div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentAlt stretchToViewportBottom\">\n" +
    "\t\t\t<div class=\"fillPane paneBg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'altBg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div data-pane=\"alt\" data-content=\"{{scene.altPaneContents}}\" x-itt-content-pane></div>\n" +
    "\t\t\t<div class=\"fillPane paneFg\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: 'altFg'\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div x-itt-magnetized class=\"fillPane videoOverlay\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'videoOverlay'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"fillPane windowFg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowFg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/scene-explore.html',
    "<!-- TODO: on enter need to scroll directly to current scene if it's not scene 1 -->\n" +
    "\n" +
    "<div class=\"clear scene-explore {{scene.layout}} {{scene.styles}}\" \n" +
    "x-ng-class='{\n" +
    "\t\"currentScene\": scene.isActive, \n" +
    "\t\"futureScene\": !scene.isActive && !scene.wasActive, \n" +
    "\t\"pastScene\": !scene.isActive && scene.wasActive,\n" +
    "\t\"nonNavigable\": scene.nonNavigable\n" +
    "}'>\n" +
    "\t<div class=\"scene\">\n" +
    "\t\t<div class=\"pane videoContainer\">\n" +
    "\t\t\t<div class=\"fillPane video\">\n" +
    "\t\t\t\t<img class=\"aspectratiopreserver\" src=\"/images/aspectratiopreserver-16x9.gif\" />\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentMain\">\n" +
    "\t\t\t<div class=\"content noSidebars\">\n" +
    "\t\t\t\t<h2 class=\"sceneTitle\" x-ng-if=\"scene.title\">{{scene.title}}</h2>\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: scene.mainPaneContents | filter:{cosmetic: false}\" class=\"item-animate\" data-force-item-template=\"default\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"pane contentAlt\">\n" +
    "\t\t\t<div x-ng-if=\"scene.startTime == 0\" class=\"matchVideoHeight\">\n" +
    "\t\t\t\t<!-- in explore view, need to pad the first scene to make room for the video -->\n" +
    "\t\t\t</div>\n" +
    "\t\t\t<div class=\"content noSidebars\">\n" +
    "\t\t\t\t<div x-ng-repeat=\"item in scene.items | layout: scene.altPaneContents | filter:{cosmetic: false}\" class=\"item-animate\" data-force-item-template=\"default\" x-itt-item=\"item\"></div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div x-itt-magnetized class=\"fillPane videoOverlay\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'videoOverlay'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/scene-video.html',
    "<div class=\"scene-video {{scene.styles}}\" x-ng-class='{\"currentScene\": scene.isActive, \"futureScene\": !scene.isActive && !scene.wasActive, \"pastScene\": !scene.isActive && scene.wasActive}'>\n" +
    "\t<div x-itt-magnetized class=\"fillPane videoOverlay\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'videoOverlay'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"scene stretchToViewportBottom\">\n" +
    "\t\t<div class=\"pane videoContainer\">\n" +
    "\t\t\t<div class=\"fillPane video\">\n" +
    "\t\t\t\t<img class=\"aspectratiopreserver\" src=\"/images/aspectratiopreserver-16x9.gif\" />\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div class=\"pane contentMain videoOverlay\">\n" +
    "\t\t<div class=\"content showCurrent noSidebars\">\n" +
    "\t\t\t<!-- may not need to filter by layout here... -->\n" +
    "\t\t\t<div class=\"item-animate transitionFade\" data-force-item-template=\"closedcaption\" x-ng-repeat=\"item in scene.items | layout: scene.mainPaneContents | transcript\" x-itt-item=\"item\"></div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div class=\"fillPane windowFg\">\n" +
    "\t\t<div x-ng-repeat=\"item in scene.items | layout: 'windowFg'\" x-itt-item=\"item\"></div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/text-h1.html',
    "<div class=\"item headerItem {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<h1>\n" +
    "\t\t{{item.annotation}}\n" +
    "\t</h1>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/text-h2.html',
    "<div class=\"item headerItem {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<h2>\n" +
    "\t\t{{item.annotation}}\n" +
    "\t</h2>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/text-pullquote-noattrib.html',
    "<div class=\"item headerItem {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"pullquote\">\n" +
    "\t\t{{item.annotation}}\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/text-pullquote.html',
    "<div class=\"item headerItem {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"pullquote\">\n" +
    "\t\t{{item.annotation}}\n" +
    "\t</div>\n" +
    "\t<div class=\"pullquoteSpeaker\">{{item.authorName}}</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/toolbar/toolbar.html',
    "<span>\n" +
    "\t<div class=\"toolbar\" x-ng-show=\"show.playerPanel\" x-ng-class=\"{isFramed: isFramed}\">\n" +
    "\n" +
    "\t\t<div class=\"modegroup buttongroup\">\n" +
    "\t\t\t<a class=\"button button-video\" x-ng-class=\"{cur: currentSceneTemplateIs('video')}\" x-ng-click=\"setSceneTemplate('video');\">\n" +
    "\t\t\t\t<span>Watch</span>\n" +
    "\t\t\t</a>\n" +
    "\t\t\t<a class=\"button button-directed\" x-ng-class=\"{cur: currentSceneTemplateIs()}\" x-ng-click=\"setSceneTemplate();\">\n" +
    "\t\t\t\t<span>Discover</span>\n" +
    "\t\t\t</a>\n" +
    "\t\t\t<a class=\"button button-explore\" x-ng-class=\"{cur: currentSceneTemplateIs('explore')}\" x-ng-click=\"setSceneTemplate('explore');\">\n" +
    "\t\t\t\t<span>Explore</span>\n" +
    "\t\t\t</a>\n" +
    "\t\t</div>\n" +
    "\t\t\n" +
    "\t\t<div x-ng-if=\"isFramed\" class=\"escapegroup buttongroup\" style=\"float:right;\">\n" +
    "\t\t\t<a x-ng-click=\"mainframeescape();\" class=\"button button-mainframeescape\">\n" +
    "\t\t\t\t<span>New window</span>\n" +
    "\t\t\t</a>\n" +
    "\t\t</div>\n" +
    "\n" +
    "\t\t<div class=\"searchgroup buttongroup\" x-ng-class=\"{cur: show.searchPanel}\" style=\"float:right; z-index:10\">\n" +
    "\t\t\t<a class=\"button button-search\" href=\"javascript: void 1;\" x-ng-click=\"toggleSearchPanel()\">\n" +
    "\t\t\t\t<span>Search</span>\n" +
    "\t\t\t</a>\n" +
    "\t\t\t<input id=\"searchtext\" type=\"text\" x-ng-model=\"searchText\" />\n" +
    "\t\t</div>\n" +
    "\t\t\n" +
    "\n" +
    "\t</div>\n" +
    "\t<div class=\"threedee\">\n" +
    "\t\t<div class=\"modal-backdrop\" x-ng-click=\"hidePanels()\" x-ng-show=\"show.navigationPanel\"></div>\n" +
    "\t\t<div class=\"modal-backdrop search-backdrop\" x-ng-click=\"hidePanels()\" x-ng-show=\"show.searchPanel\"></div>\n" +
    "\t\t<div x-ng-show=\"show.navigationPanel\" class=\"sidePanel navigationPanel\">\n" +
    "\t\t\t<div x-ng-controller=\"NavigationPanelController\">\n" +
    "\t\t\t\t<h2>{{episode.title}}</h2>\n" +
    "\t\t\t\t<div class=\"scene\" x-ng-if=\"scene.title\" x-ng-repeat=\"scene in scenes\" x-ng-class=\"{currentScene: scene.isActive}\" x-ng-click=\"gotoScene(scene)\">\n" +
    "\t\t\t\t\t<span class=\"displayTime\">{{scene.displayTime}}</span>\n" +
    "\t\t\t\t\t<p>\n" +
    "\t\t\t\t\t\t<a href=\"javascript:void 1;\">{{scene.title}}</a>\n" +
    "\t\t\t\t\t\t<br>{{scene.description}}\n" +
    "\t\t\t\t\t</p>\n" +
    "\t\t\t\t</div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t\t<div x-ng-show=\"show.searchPanel\" class=\"sidePanel searchPanel\">\n" +
    "\t\t\t<div x-ng-if=\"show.searchPanelInternals\" x-ng-controller=\"SearchPanelController\">\n" +
    "\t\t\t\t\n" +
    "\t\t\t\t<div class=\"searchfilters\">\n" +
    "\t\t\t\t<label x-ng-show=\"sortBy!=='startTime'\"><input type=\"radio\" name=\"searchsort\" id=\"searchsort\" x-ng-model=\"sortBy\" value=\"startTime\"> Sorted by <span class=\"fakelink\">type</span></label>\n" +
    "\t\t\t\t<label x-ng-show=\"sortBy==='startTime'\"><input type=\"radio\" name=\"searchsort\" id=\"searchsort\" x-ng-model=\"sortBy\" value=\"type\"> Sorted by <span class=\"fakelink\">time</span></label>\n" +
    "\t\t\t\t</div>\n" +
    "\t\t\t\t<div class=\"scrollContainer\">\n" +
    "\t\t\t\t\t<div class=\"searchResults\">\n" +
    "\t\t\t\t\t\t<!-- TODO:\n" +
    "\t\t\t\t\t- Wire up all types checkbox\n" +
    "\t\t\t\t\t- Check ordering in items by type\n" +
    "\t\t\t\t\t- Hide type header when no child items are visible\n" +
    "\t\t\t\t-->\n" +
    "\t\t\t\t\t\t<!-- sorted by start time -->\n" +
    "\t\t\t\t\t\t<div x-ng-if=\"sortBy == 'startTime'\">\n" +
    "\t\t\t\t\t\t\t<div x-ng-repeat=\"scene in scenes\">\n" +
    "\t\t\t\t\t\t\t\t<h3 x-ng-if=\"scene.title\">{{scene.title}}</h3>\n" +
    "\t\t\t\t\t\t\t\t<div class=\"item\" x-ng-repeat=\"item in scene.items | orderBy:'startTime' | filter:{'searchableText': searchText, 'cosmetic': false} | type:searchTypes\">\n" +
    "\t\t\t\t\t\t\t\t\t<span class=\"displayTime\"><a href=\"javascript:void 1\" x-ng-click=\"gotoItem(item)\">{{item.displayTime}}</a>\n" +
    "\t\t\t\t\t\t\t\t\t</span>\n" +
    "\t\t\t\t\t\t\t\t\t<span x-ng-if=\"item.type==='annotation'\" class=\"type\">{{item.authorName}}</span>\n" +
    "\t\t\t\t\t\t\t\t\t<span x-ng-if=\"item.type!=='annotation'\" class=\"type\">({{prettyTypeMap[item.type]}})</span>\n" +
    "\t\t\t\t\t\t\t\t\t<div class=\"description\" ng-bind-html=\"item.trustedDisplayText | highlight: searchText\"></div>\n" +
    "\t\t\t\t\t\t\t\t</div>\n" +
    "\t\t\t\t\t\t\t</div>\n" +
    "\t\t\t\t\t\t</div>\n" +
    "\n" +
    "\t\t\t\t\t\t<!-- sorted by type -->\n" +
    "\t\t\t\t\t\t<div x-ng-if=\"sortBy == 'type'\">\n" +
    "\t\t\t\t\t\t\t<div class=\"sortedbytype\" x-ng-repeat=\"(type, items) in allItemsByType | orderBy:'type'\" x-ng-if=\"searchTypes[type]\">\n" +
    "\t\t\t\t\t\t\t\t<h3>{{prettyTypeMap[type]}}</h3>\n" +
    "\t\t\t\t\t\t\t\t<div class=\"item\" x-ng-repeat=\"item in items | orderBy:'startTime' | type:searchTypes | filter:{'searchableText': searchText, 'cosmetic': false}\">\n" +
    "\t\t\t\t\t\t\t\t\t<span class=\"displayTime\"><a href=\"javascript:void 1\" x-ng-click=\"gotoItem(item)\">{{item.displayTime}}</a>\n" +
    "\t\t\t\t\t\t\t\t\t</span>\n" +
    "\t\t\t\t\t\t\t\t\t<span x-ng-if=\"item.type==='annotation'\" class=\"type\">{{item.authorName}}</span>\n" +
    "\t\t\t\t\t\t\t\t\t<span x-ng-if=\"item.type!=='annotation'\" class=\"type\">({{prettyTypeMap[item.type]}})</span>\n" +
    "\t\t\t\t\t\t\t\t\t<div class=\"description\" ng-bind-html=\"item.trustedDisplayText | highlight: searchText\"></div>\n" +
    "\t\t\t\t\t\t\t\t</div>\n" +
    "\t\t\t\t\t\t\t</div>\n" +
    "\t\t\t\t\t\t</div>\n" +
    "\t\t\t\t\t</div>\n" +
    "\t\t\t\t</div>\n" +
    "\t\t\t</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\n" +
    "\t<!-- TODO ARIA markup on all clickables -->\n" +
    "\t<div class=\"injectedvideocontrols vjs-story-skin\">\n" +
    "\t\t<div x-ng-click=\"showSceneMenu()\" class=\"video-scenemenu vjs-control\">\n" +
    "\t\t\t<a href=\"javascript: void 1;\">\n" +
    "\t\t\t\t<span class=\"vjs-control-text\">Scene list</span>\n" +
    "\t\t\t</a>\n" +
    "\t\t</div>\n" +
    "\n" +
    "\n" +
    "\t\t<div x-ng-if=\"curScene.$prevScene\" class=\"video-prevscene vjs-control\">\n" +
    "\t\t\t<a x-ng-click=\"gotoTime(curScene.$prevScene.startTime + 0.1)\">\n" +
    "\t\t\t\t<span class=\"vjs-control-text\">Previous scene</span>\n" +
    "\t\t\t</a>\n" +
    "\t\t</div>\n" +
    "\t\t<div x-ng-if=\"curScene.$nextScene\" class=\"video-nextscene vjs-control\">\n" +
    "\t\t\t<a x-ng-click=\"gotoTime(curScene.$nextScene.startTime)\">\n" +
    "\t\t\t\t<span class=\"vjs-control-text\">Next scene</span>\n" +
    "\t\t\t</a>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\n" +
    "\n" +
    "\t<div x-ng-show=\"show.introPanel\" class=\"intropanel\">\n" +
    "\t\t<div class=\"pane introtext\">\n" +
    "\t\t<h1>\n" +
    "\t\t\t{{episode.title}}\n" +
    "\t\t</h1>\n" +
    "\t\t<p>\n" +
    "\t\t\t{{episode.description}}\n" +
    "\t\t</p>\n" +
    "\t\t</div>\n" +
    "\t\t\t<div class=\"pane videoContainer\">\n" +
    "\t\t\t\t<div class=\"fillPane video\">\n" +
    "\t\t\t\t\t<img class=\"aspectratiopreserver\" src=\"/images/aspectratiopreserver-16x9.gif\" />\n" +
    "\t\t\t\t</div>\n" +
    "\t\t\t</div>\n" +
    "\t</div>\n" +
    "\n" +
    "\t<div x-ng-if=\"forcedEscape\" x-itt-magnetized class=\"videoOverlay\" style=\"pointer-events: auto;\">\n" +
    "\t\t<div x-ng-click=\"mainframeescape();\" class=\"escapelink forcedEscape\"></div>\n" +
    "\t<div id=\"footertrigger\" x-ng-mouseenter=\"showVideoControls()\"></div>\n" +
    "\n" +
    "</span>\n"
  );


  $templateCache.put('templates/transcript-closedcaption.html',
    "<div class=\"item\" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"authorName\">{{item.authorName}}</div>\n" +
    "\t</div>\n" +
    "\t<div class=\"text\">{{item.annotation}}</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transcript-default.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"authorName\">{{item.authorName}}</div>\n" +
    "\t</div>\n" +
    "\t<!-- <div class=\"icon\"><img x-ng-src=\"{{item.authorThumbSrc}}\"><div class=\"clear\"></div></div> -->\n" +
    "\t<div class=\"text\">\n" +
    "\t\t{{item.annotation}}\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transcript-withthumbnail-alt.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"icon\" style=\"float:right\">\n" +
    "\t\t\t<img x-ng-src=\"{{item.authorThumbSrc}}\">\n" +
    "\t\t\t<div class=\"clear\"></div>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"authorName\">{{item.authorName}}</div>\n" +
    "\t</div>\n" +
    "\t<div class=\"text\">\n" +
    "\t\t{{item.annotation}}\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transcript-withthumbnail.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t</div>\n" +
    "\t<div class=\"icon\" style=\"float:left; margin-right: 1em;\">\n" +
    "\t\t<img x-ng-src=\"{{item.authorThumbSrc}}\">\n" +
    "\t\t<div class=\"clear\"></div>\n" +
    "\t</div>\n" +
    "\t<div class=\"authorName\">{{item.authorName}}</div>\n" +
    "\t<div class=\"text\">\n" +
    "\t\t{{item.annotation}}\n" +
    "\t</div>\n" +
    "\t<div class=\"clear\"></div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transmedia-caption.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"category\">\n" +
    "\t\t\t<!--{{item.category}}-->\n" +
    "\t\t\t<!--<span x-ng-if=\"item.required\">(Required viewing)</span>-->\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\n" +
    "\t<div class=\"captioncontainer\">\n" +
    "\t\t<img x-ng-src=\"{{item.source}}\" style=\"width:100%\">\n" +
    "\t\t<div class=\"caption\">\n" +
    "\t\t\t<div class=\"title\">{{item.title}}</div>\n" +
    "\t\t\t<div class=\"text\">{{item.description}}</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n"
  );


  $templateCache.put('templates/transmedia-embed-youtube.html',
    "<!-- TODO: clean up the YT url, add our own params, probably use their player API so we can hook into play/pause events -->\n" +
    "\n" +
    "\n" +
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"category\">\n" +
    "\t\t\t<!--{{item.category}}-->\n" +
    "\t\t\t<span x-ng-if=\"item.required\">(Required viewing)</span>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\n" +
    "\t<div class=\"detail\" style=\"width: 100%;position: relative;padding-bottom: 56.25%;height: 0;\">\n" +
    "\t\t<iframe x-ng-src=\"{{item.source}}\" style=\"position:absolute; width: 100%; height: 100%; \"></iframe>\n" +
    "\t</div>\n" +
    "\n" +
    "\t<div class=\"text\">\n" +
    "\t\t{{item.description}}\n" +
    "\t</div>\n" +
    "\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transmedia-image-default.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"category\">\n" +
    "\t\t\t<!--{{item.category}}-->\n" +
    "\t\t\t<!--<span x-ng-if=\"item.required\">(Required viewing)</span>-->\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<!-- <div class=\"icon\"><img x-ng-src=\"{{item.thumbSrc}}\"></div> -->\n" +
    "\t<div class=\"text\">\n" +
    "\t\t<div class=\"title\">\n" +
    "\t\t\t<a href=\"javascript:void 1;\" x-ng-click=\"toggleDetailView()\">{{item.title}}</a>\n" +
    "\t\t</div>\n" +
    "\t\t<div class=\"text\">{{item.description}}</div>\n" +
    "\t</div>\n" +
    "\t<div class=\"detail\" x-ng-if=\"item.showInlineDetail\">\n" +
    "\t\t<img x-ng-src=\"{{item.source}}\" style=\"width: 100%\">\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transmedia-image-plain.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive\n" +
    "}'>\n" +
    "\t<img x-ng-src=\"{{item.source}}\" />\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transmedia-link-default.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"category\">\n" +
    "\t\t\t<!--{{item.category}}-->\n" +
    "\t\t\t<span x-ng-if=\"item.required\">(Required viewing)</span>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<!-- <div class=\"icon\"><img x-ng-src=\"{{item.thumbSrc}}\"></div> -->\n" +
    "\t<div class=\"text\">\n" +
    "\t\t<div class=\"title\"><a href=\"javascript:void 1;\" x-ng-click=\"toggleDetailView()\">{{item.title}}</a>\n" +
    "\t\t</div>\n" +
    "\t\t<div>{{item.description}}</div>\n" +
    "\t</div>\n" +
    "\t<div class=\"detail\" x-ng-if=\"item.showInlineDetail\">\n" +
    "\t\t<a href=\"{{item.source}}\" target=\"_blank\" class=\"escapelink\">(new window)</a>\n" +
    "\t\t<div style=\"-webkit-overflow-scrolling:touch; overflow: auto; width: 100%; height: 320px\">\n" +
    "\t\t\t<iframe x-ng-src=\"{{item.source}}\" width=\"100%\" height=\"300px\"></iframe>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transmedia-link-frameicide.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"category\">\n" +
    "\t\t\t<!--{{item.category}}-->\n" +
    "\t\t\t<span x-ng-if=\"item.required\">(Required viewing)</span>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<!-- <div class=\"icon\"><img x-ng-src=\"{{item.thumbSrc}}\"></div> -->\n" +
    "\t<div class=\"text\">\n" +
    "\t\t<div class=\"title\"><a href=\"{{item.source}}\" class=\"\" target=\"_top\">{{item.title}}</a>\n" +
    "\t\t</div>\n" +
    "\t\t<div>{{item.description}}</div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transmedia-link-icon.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"icon\">\n" +
    "\t\t<a href=\"{{item.source}}\" target=\"_blank\">\n" +
    "\t\t\t<img x-ng-src=\"{{item.thumbSrc}}\">\n" +
    "\t\t</a>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transmedia-link-noembed.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"category\">\n" +
    "\t\t\t<!--{{item.category}}-->\n" +
    "\t\t\t<span x-ng-if=\"item.required\">(Required viewing)</span>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<!-- <div class=\"icon\"><img x-ng-src=\"{{item.thumbSrc}}\"></div> -->\n" +
    "\t<div class=\"text\">\n" +
    "\t\t<div class=\"title\"><a href=\"{{item.source}}\" class=\"escapelink\" target=\"_blank\">{{item.title}}</a>\n" +
    "\t\t</div>\n" +
    "\t\t<div>{{item.description}}</div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transmedia-link-youtube.html',
    "<!-- TODO: clean up the YT url, add our own params, probably use their player API so we can hook into play/pause events -->\n" +
    "\n" +
    "\n" +
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"category\">\n" +
    "\t\t\t<!--{{item.category}}-->\n" +
    "\t\t\t<span x-ng-if=\"item.required\">(Required viewing)</span>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<!-- <div class=\"icon\"><img x-ng-src=\"{{item.thumbSrc}}\"></div> -->\n" +
    "\t<div class=\"text\">\n" +
    "\t\t<div class=\"title\"><a href=\"javascript:void 1;\" x-ng-click=\"toggleDetailView()\">{{item.title}}</a>\n" +
    "\t\t</div>\n" +
    "\t\t<div>{{item.description}}</div>\n" +
    "\t</div>\n" +
    "\t<div class=\"detail\" x-ng-if=\"item.showInlineDetail\" style=\"width: 100%;position: relative;padding-bottom: 56.25%;height: 0;\">\n" +
    "\t\t<iframe x-ng-src=\"{{item.source}}\" style=\"position:absolute; width: 100%; height: 100%; \"></iframe>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transmedia-linkonly.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"category\">\n" +
    "\t\t\t<!--{{item.category}}-->\n" +
    "\t\t\t<span x-ng-if=\"item.required\">(Required viewing)</span>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<!-- <div class=\"icon\"><img x-ng-src=\"{{item.thumbSrc}}\"></div> -->\n" +
    "\t<div class=\"text\">\n" +
    "\t\t<div class=\"title\"><a href=\"{{item.source}}\" class=\"escapelink\" target=\"_blank\">{{item.title}}</a>\n" +
    "\t\t</div>\n" +
    "\t\t<div>{{item.description}}</div>\n" +
    "\t</div>\n" +
    "</div>\n"
  );


  $templateCache.put('templates/transmedia-slidingcaption.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"category\">\n" +
    "\t\t\t<!--{{item.category}}-->\n" +
    "\t\t\t<span x-ng-if=\"item.required\">(Required viewing)</span>\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\n" +
    "\t<div class=\"captioncontainer\">\n" +
    "\t\t<img x-ng-src=\"{{item.source}}\" style=\"width:100%\">\n" +
    "\t\t<div class=\"caption slidingcaption\">\n" +
    "\t\t\t<div class=\"title\">{{item.title}}</div>\n" +
    "\t\t\t<div class=\"text\">{{item.description}}</div>\n" +
    "\t\t</div>\n" +
    "\t</div>\n"
  );


  $templateCache.put('templates/transmedia-thumbnail.html',
    "<div class=\"item {{item.layout}} {{item.styles}} \" x-ng-class='{\n" +
    "\t\"currentItem\": item.isActive, \n" +
    "\t\"futureItem\": !item.isActive && !item.wasActive, \n" +
    "\t\"pastItem\": !item.isActive && item.wasActive,\n" +
    "\t\"isRequired\": item.required,\n" +
    "\t\"isCosmetic\": item.cosmetic\n" +
    "}'>\n" +
    "\t<div class=\"itemHead\">\n" +
    "\t\t<div class=\"startTime displayTime\" x-ng-click=\"gotoItem()\">{{item.displayTime}}</div>\n" +
    "\t\t<div class=\"category\">\n" +
    "\t\t\t<!--{{item.category}}-->\n" +
    "\t\t\t<!--<span x-ng-if=\"item.required\">(Required viewing)</span>-->\n" +
    "\t\t</div>\n" +
    "\t</div>\n" +
    "\t<div class=\"thumbnail\" x-ng-class=\"{fullsize: item.showInlineDetail || item.isActive}\" x-ng-click=\"toggleDetailView()\">\n" +
    "\t\t<img x-ng-src=\"{{item.source}}\">\n" +
    "\t</div>\n" +
    "\t<div class=\"text\">\n" +
    "\t\t<div class=\"title\">{{item.title}}</div>\n" +
    "\t\t{{item.description}}\n" +
    "\t</div>\n" +
    "</div>\n" +
    "</div>\n"
  );


}]);
'use strict';

// UI Error Controller (Shows an error through the UI)
angular.module('com.inthetelling.player')
	.controller('UIErrorController', function ($scope, $rootScope) {
		$scope.errorMsg = $rootScope.uiErrorMsg || 'The requested route does not exist.';
		$scope.errorDetails = $rootScope.uiErrorDetails;
	});

'use strict';

//TODO we badly need an episode directive

// Episode Controller
angular.module('com.inthetelling.player')
	.controller('EpisodeController', function ($interval, dataSvc, modelFactory, cuePointScheduler, $scope, $rootScope, $location, $routeParams,videojs,$window) {


		// STUFF THAT MUST RUN FIRST:
		
		// HACK HACK HACK HACKITY HACK HACK HACK
		// videojs and cuePointScheduler (and probably others) are currently set up as singletons; both die horrible deaths on route changes (even to the same route).
		// We'll need to fix that asap. For now, use videojs.player as a convenient way to detect if we're starting fresh, and if not do a brute-force reload of the page.
		// It's ugly, but not as ugly as my attempts to de-singletonize greg's code...
		if (videojs.player) {
//			console.log("Route change: forcing refresh");
			$window.location.reload();
		}

			// Frame detect.  Don't use !== as IE8 gets that wrong
			/* jshint -W116 */
			$rootScope.isFramed = (window.parent != window);
			/* jshint +W116 */

			// iPad or iPhone detect.
			// HACK put in rootScope for easy access from vid
			$rootScope.isIPad = (navigator.platform.indexOf('iPad') > -1);
			$rootScope.isIPhone = (navigator.platform.indexOf('iPhone') > -1 || navigator.platform.indexOf('iPod') > -1);

		// patches up scrolling in iframe on ipad:
		if (($rootScope.isIPad || $rootScope.isIPod || $rootScope.isIPhone) && $rootScope.isFramed) {
			var w = angular.element(window);
			angular.element('#CONTAINER')
				.height(w.height())
				.width(w.width())
				.addClass('iosScrollFix');
				
			// can't bind to window resize events, that's a crasher in ios safari. So we make our own.
			$interval( function(){
					$scope.IOSFrameheight = angular.element(window).height();
					$scope.IOSFramewidth = angular.element(window).width();
			},100,0,false);

			// Safari helpfully tries to resize the iframe to match our contents, so we have to beat it to the punch by first
			// resizing our contents to match the iframe.  This takes some doing, because it's a moving target:
			
			$scope.$watch(function() {return $scope.IOSFramewidth},function(newV,oldV) {
				if (oldV === undefined) {return}
				if (newV > oldV) {
					// We still need to set this slightly smaller than the actual window size, or else we won't be able to shrink later
					angular.element('#CONTAINER').height($scope.IOSFrameheight-1).width($scope.IOSFramewidth-1);
				} else {
					// Shrinking.  THis is harder.  Make it too small first:
					angular.element('#CONTAINER').height(1).width(1);
					// update the scope vals before the next digest, and before Safari has time to change it on us:
					$scope.IOSFrameheight = angular.element(window).height();
					$scope.IOSFramewidth = angular.element(window).width();
					// and then immediately change the container to match before our interval setter has time to change that on us:
					angular.element('#CONTAINER').height($scope.IOSFrameheight-1).width($scope.IOSFramewidth-1);
				}
			});
			
			// For now we're not going to support iPad1 or iPad2 inside an iframe.  iPad3 is ok
			if (window.devicePixelRatio < 2) {
				// This will place a giant escape button on top of the video
				$scope.forcedEscape=true;
			}
		}

		// OK, now that that's all out of the way we can actually start the app.


		dataSvc.get($routeParams, function (data) { // ON SUCCESS


			var i, j;

			// To be used by framebreaker (see toolbar controller):
			$scope.episodeID = $routeParams.epId;
			$scope.authKey = $routeParams.authKey;

			// Create an episode model.
			$scope.episode = modelFactory.createEpisodeModel(data.episode);

			// Create a collection of scene models
			$scope.scenes = [];
			for (i = 0; i < data.events.length; i++) {
				if (data.events[i].type === "scene") {

					// scene model
					var sceneModel = modelFactory.createSceneModel(data.events[i]);

					// subscribe the scene model to the cuePoint scheduler service for state awareness
					// use a closure to preserve variable scope in each loop iteration
					(function (sceneModel) {
						cuePointScheduler.subscribe({
							begin: sceneModel.startTime,
							end: sceneModel.endTime
						}, function (span, evt, playheadPos) {
							$scope.$apply(function () {
								if (evt === cuePointScheduler.ENTER) {
									sceneModel.isActive = true;
								} else if (evt === cuePointScheduler.EXIT) {
									sceneModel.isActive = false;
									sceneModel.wasActive = true;
								}
							});
						});
					})(sceneModel);

					$scope.scenes.push(sceneModel);
				}
			}

			// create item/transmedia models and place them into the items collection of their respective scenes
			for (i = 0; i < data.events.length; i++) {
				if (data.events[i].type !== "scene") {

					// base item model
					var itemModel = modelFactory.createItemModel(data.events[i]);

					// subscribe the item model to the cuePoint scheduler for state awareness
					// use a closure to preserve variable scope in each loop iteration
					(function (itemModel) {


		// HACK HACK HACK HACKITY HACK HACK HACK
		// We should adjust the end time to allow for transitions ONLY in cases where showCurrent is true in the content pane, and transitions are in use on the item, and the next item starts at the same time the current item ends.
		// For now applying it everywhere, because the episode model has no knowledge of showcurrent or transitions at this point.
		// This will become easier when there's an explicit derived-values service...
						itemModel.adjustedEndTime =
							(itemModel.type === 'annotation' && itemModel.startTime +1 < itemModel.endTime) ?
								itemModel.endTime -1 :
								itemModel.endTime
							;
					
						cuePointScheduler.subscribe({
							begin: itemModel.startTime,
							end: itemModel.adjustedEndTime
						}, function (span, evt, playheadPos) {
							$scope.$apply(function () {
								if (evt === cuePointScheduler.ENTER) {
									itemModel.isActive = true;
								} else if (evt === cuePointScheduler.EXIT) {
									itemModel.isActive = false;
									itemModel.wasActive = true;
								}
							});
						});
					})(itemModel);

					// Add the item model to its relevant scene
					for (j = 0; j < $scope.scenes.length; j++) {
						if (itemModel.startTime >= $scope.scenes[j].startTime &&
							itemModel.startTime < $scope.scenes[j].endTime) {
							$scope.scenes[j].items.push(itemModel);
							break;
						}
					}
				}
			}

			//Sort scenes and items within scenes
			$scope.scenes.sort(function (a, b) {
				return a.startTime - b.startTime;
			});
			for (i = 0; i < $scope.scenes.length; i++) {
				$scope.scenes[i].items.sort(function (a, b) {
					return a.startTime - b.startTime;
				});
			}

			// Inject references to nextScene, prevScene values here, as long as we already have a sorted array of them.
			// TODO these are derived values; refactor.
			// Skips untitled scenes; these are used for navigation only.
			for (i = 1; i < $scope.scenes.length; i++) {
				for (j = i - 1; j > -1; j = j - 1) {
					if ($scope.scenes[j].title) {
						$scope.scenes[i].$prevScene = $scope.scenes[j];
						break;
					}
				}
			}
			for (i = 0; i < $scope.scenes.length - 1; i++) {
				for (j = i + 1; j < $scope.scenes.length; j++) {
					if ($scope.scenes[j].title) {
						$scope.scenes[i].$nextScene = $scope.scenes[j];
						break;
					}
				}
			}



//			console.log("Created episode scope:", $scope);


		}, function (data) { // ON ERROR
			// TODO: Should probably be using a service instead of root scope
			// TODO: dataSvc is always returning a 404 even when the epId is correct...?

			$rootScope.uiErrorMsg = "Wasn't able to load episode data. Sorry!";
			$rootScope.uiErrorDetails = JSON.stringify(data);
			$location.path('/error');
		});

	});

'use strict';

// Controller for ittItem
angular.module('com.inthetelling.player')
	.controller('ItemController', function ($scope, videojs) {



		// convenience method to set video time
		$scope.gotoItem = function () {
			videojs.player.currentTime($scope.item.startTime);
		};

	});

'use strict';


// Controller for ittToolbar
angular.module('com.inthetelling.player')
	.controller('ToolbarController', function ($scope) {
	});

'use strict';

// Controller for the navigation panel overlay
angular.module('com.inthetelling.player')
	.controller('NavigationPanelController', function ($scope, videojs) {

		// convenience method for the template to change playhead position
		$scope.gotoScene = function (scene) {
			// set the video playhead to the scene's start time
			videojs.player.currentTime(scene.startTime);
			$scope.hidePanels();
		};

	});

'use strict';

// Controller for the search panel results
angular.module('com.inthetelling.player')
	.controller('SearchPanelController', function ($scope, videojs, $sce) {

		// map for the search panel checkboxes to bind to, which can also be passed to the type filter
		$scope.searchTypes = {
			annotation: true,
			link: true,
			slide: true,
			indepth: true,
			project: true,
			discussion: true
		};

		// for the sort control to bind to
		$scope.sortBy = "startTime";

		// map type literals to pretty/printable version
		$scope.prettyTypeMap = {
			annotation: "Transcript",
			link: "Link",
			slide: "Slide",
			indepth: "In Depth",
			project: "Project",
			discussion: "Discussion"
		};

		// create a dictionary of all items keyed by their type, for easy view iteration
		// TODO: JSPerfTest this to see how expensive it is and move it to main controller if necessary
		$scope.allItemsByType = {};
		var i, j;
		for (i = 0; i < $scope.scenes.length; i++) {
			for (j = 0; j < $scope.scenes[i].items.length; j++) {
				if (!$scope.allItemsByType[$scope.scenes[i].items[j].type]) {
					$scope.allItemsByType[$scope.scenes[i].items[j].type] = [];
				}
				// Using $sce here and in the highlight filter, not sure if we need both TODO check this
				$scope.scenes[i].items[j].searchableText = ($scope.scenes[i].items[j].annotation || $scope.scenes[i].items[j].description);
				$scope.scenes[i].items[j].trustedDisplayText = $sce.trustAsHtml($scope.scenes[i].items[j].searchableText);
				$scope.allItemsByType[$scope.scenes[i].items[j].type].push($scope.scenes[i].items[j]);
			}
		}

		// convenience method for the template to change playhead position
		$scope.gotoItem = function (item) {
			// set the video playhead to the item's start time
			videojs.player.currentTime(item.startTime);
		};

	});

'use strict';

/*
	Data service handles the retrieval and aggregation of all the data required to show
	a complete episode in the player. Data service can run against local data or api data,
	based on value of config.localData.
*/
/* 
TODO: Refactor this class to utilize $http and/or $resource level caching, and just
make the requests every time. This way it can be used like a real service class and nobody
has to worry about calling get() before getAssetById() for example. It will all be async,
but just implement the promise api for consumers to use the service in a familiar way.
Service will then be capable of full crud, and can flush appropriate caches in the underlying
$http/$resources when POST/PUT methods are called.

TODO: tidy up the various authentication methods:
 - local first
 - authKey = local
 - api key (is it working?)
 - auth check
*/


angular.module('com.inthetelling.player')
	.factory('dataSvc', function (config, $route, $location, $http, $q, _, $rootScope) {

		// Cache all the data returned from dataSvc.get(). This data will be used for all the
		// individual lookup methods like dataSvc.getAssetById(). Currently these individual
		// lookup methods are synchronous and do not use the apis or write to the cache.
		var data;


		var svc = {};

		// Retrieve and cache the full set of data required to display an episode. Method is async and
		// will get data either from a local .json file or from apis.
		svc.get = function (routeParams, callback, errback) {

			var episodeId = routeParams.epId;
			var authKey = routeParams.authKey;


			// new up an empty data object
			data = {};

			// Local Data
			if (config.localData || authKey === 'local') {
				//			console.log("dataSvc.get() [Mode: Local Data]");
				$http({
					method: 'GET',
					url: config.localDataBaseUrl + '/' + episodeId + '.json'
				})
					.success(function (data, status, headers, config) {
						callback(data);
					})
					.error(function (data, status, headers, config) {
						errback(data);
					});
			}
			// API Data
			else {
				//			console.log("dataSvc.get() [Mode: API Data]");

				// Check API authentication first.
				// TODO de-nest this code
				$http.get(config.apiDataBaseUrl + "/v1/check_signed_in")
					.success(function(authData,authStatus) {
					if (authData.signed_in === true) {
						// The server is happy with us, and we might ahve the auth cookie at this point.
						// But safari mayt have blocked it if we're in an iframe, so we have do make a second call to check _that_.
						// Yes, this is silly. TODO jsut use a header token instead of a cookie so this isn't necessary
						
						$http.get(config.apiDataBaseUrl + "/v1/is_authenticated").success(function(authData) {
							if (authData.has_cookie === true) {
								// All good, go get the real data
								svc.batchAPIcalls(routeParams, callback, errback);
							} else {
								// cookie was blocked so we have to bounce into window.top (which will bounce immediately back to history(-1)
								if (routeParams.return_to) {
									window.top.location.href = config.apiDataBaseUrl+"/v1/get_authenticated?return_to=" + routeParams.return_to;
								} else {
									// Parent frame isn't telling us their location and we can't get it directly... all we can do is ask them to launch the player in a new window:
									
									// TODO
								}
							}
						}).error(function(authData) {
							$rootScope.uiErrorMsg = "Authentication failed (is_cookie_set didn't return, or returned something other than true or false)";
							$rootScope.uiErrorDetails = JSON.stringify(authData);
							$location.path('/error');
						});
					} else {
						$rootScope.uiErrorMsg = "Authentication failed (check_signed_in returned false)";
						$rootScope.uiErrorDetails = JSON.stringify(authData);
						$location.path('/error');
					}
				}).error(function (authData,authStatus) {
					$rootScope.uiErrorMsg = "Authentication failed (check_signed_in didn't return, or returned something other than true or false)";
					$rootScope.uiErrorDetails = JSON.stringify(authData);
					$location.path('/error');
				});
			}
		};

		// retrieves the episode data from the API. Call only through svc.get
		svc.batchAPIcalls = function(routeParams, callback, errback) {
			var episodeId = routeParams.epId;
			var authKey = routeParams.authKey;

				/*
				API Flow:
				/v1/episodes/<episode_id>
					/v1/containers/<resp.container_id>/assets
					/v1/containers/<resp.container_id>
						/v1/containers/<resp.parent_id>/assets
						/v1/containers/<resp.parent_id>
							/v1/containers/<resp.parent_id>/assets
				/v2/episodes/<episode_id>/events
				/v1/templates
				/v1/layouts
				/v1/styles
				TODO: GEt event categories also, they will eventually be used in the player
			*/

			// if there's an API token in the config, use it in a header; otherwise pass access_token as a url param.
			// NOTE this is not in use currently AFAIK
			var authParam = "";
			if (config.apiAuthToken) {
				$http.defaults.headers.get = {
					'Authorization': config.apiAuthToken
				};
			} else {
				authParam = (authKey) ? "?access_token=" + authKey : "";
			}

			// first set of calls
			var firstSet = $http.get(config.apiDataBaseUrl + '/v1/episodes/' + episodeId + authParam)
				.then(function (response) {
					data.episode = response.data;
					//console.log(response.config.url + ":", response.data);
					return $q.all([
						$http.get(config.apiDataBaseUrl + '/v1/containers/' + response.data.container_id + '/assets' + authParam),
						$http.get(config.apiDataBaseUrl + '/v1/containers/' + response.data.container_id + authParam)
					]);
				})
				.then(function (responses) {
					data.assets = responses[0].data.files;
					//console.log(responses[0].config.url + ":", responses[0].data);
					//console.log(responses[1].config.url + ":", responses[1].data);
					return $q.all([
						$http.get(config.apiDataBaseUrl + '/v1/containers/' + responses[1].data[0].parent_id + '/assets' + authParam),
						$http.get(config.apiDataBaseUrl + '/v1/containers/' + responses[1].data[0].parent_id + authParam)
					]);
				})
				.then(function (responses) {
					data.assets = data.assets.concat(responses[0].data.files);
					//console.log(responses[0].config.url + ":", responses[0].data);
					//console.log(responses[1].config.url + ":", responses[1].data);
					return $http.get(config.apiDataBaseUrl + '/v1/containers/' + responses[1].data[0].parent_id + '/assets' + authParam);
				})
				.then(function (response) {
					data.assets = data.assets.concat(response.data.files);
					//console.log(response.config.url + ":", response.data);
				});

			// second set of calls
			var secondSet = $q.all([
				$http.get(config.apiDataBaseUrl + '/v2/episodes/' + episodeId + '/events' + authParam),
				$http.get(config.apiDataBaseUrl + '/v1/templates' + authParam),
				$http.get(config.apiDataBaseUrl + '/v1/layouts' + authParam),
				$http.get(config.apiDataBaseUrl + '/v1/styles' + authParam)
			])
				.then(function (responses) {
					data.events = responses[0].data;
					data.templates = responses[1].data;
					data.layouts = responses[2].data;
					data.styles = responses[3].data;
				});

			// completion
			$q.all([
				firstSet,
				secondSet
			])
				.then(function (responses) {
					// success
					//				console.log("Compiled API Data:", data);

					//// DIRTY PREPROCESSING HACK ////
					// TODO: Remove it when api updates the type field to be lowercase
					for (var i = 0; i < data.events.length; i++) {
						data.events[i].type = data.events[i].type.toLowerCase();
						data.events[i]._type = data.events[i]._type.toLowerCase();
					}
					///////////////////

					callback(data);
			}, function(responses) {
				// error
				errback(responses);
			});
		};


		// Retrieve the data for an asset based on its id. Method is synchronous and will scan the data cache,
		// returning undefined if the item is not found.
		svc.getAssetById = function (id) {
			if (!_.isArray(data.assets)) {
				return;
			}
			var i;
			for (i = 0; i < data.assets.length; i++) {
				if (data.assets[i]._id === id) {
					return data.assets[i];
				}
			}
		};

		// Retrieve the data for a template based on its id. Method is synchronous and will scan the data cache,
		// returning undefined if the item is not found.
		svc.getTemplateById = function (id) {
			if (!_.isArray(data.templates)) {
				return;
			}
			var i;
			for (i = 0; i < data.templates.length; i++) {
				if (data.templates[i]._id === id) {
					return data.templates[i];
				}
			}
		};

		// Retrieve the data for a layout based on its id. Method is synchronous and will scan the data cache,
		// returning undefined if the item is not found.
		svc.getLayoutById = function (id) {
			if (!_.isArray(data.layouts)) {
				return;
			}
			var i;
			for (i = 0; i < data.layouts.length; i++) {
				if (data.layouts[i]._id === id) {
					return data.layouts[i];
				}
			}
		};

		// Retrieve the data for a style based on its id. Method is synchronous and will scan the data cache,
		// returning undefined if the item is not found.
		svc.getStyleById = function (id) {
			if (!_.isArray(data.styles)) {
				return;
			}
			var i;
			for (i = 0; i < data.styles.length; i++) {
				if (data.styles[i]._id === id) {
					return data.styles[i];
				}
			}
		};

		return svc;
	});

'use strict';

angular.module('com.inthetelling.player')
	.factory('modelFactory', function (dataSvc, _) {

		// test if the passed object is a 24-bit uid
		var isUid = function (test) {
			if (_.isString(test) && test.match(/^[0-9a-fA-F]{24}$/)) {
				return true;
			}
			return false;
		};

		// Takes a template id, looks it up, and returns the template url
		// Will return (reflect) the passed property if not a valid id
		var resolveTemplateUrl = function (templateId) {
			if (isUid(templateId)) {
				var template = dataSvc.getTemplateById(templateId);
				if (template) {
					return template.url;
				} else {
					console.error("Template lookup failed for:", templateId);
				}
			}
			return templateId;
		};

		// Takes an array of layout ids, looks them all up, and returns a concatenated css string
		// Will return (reflect) the passed property if not a valid id
		var resolveLayoutCSS = function (layoutIds) {
			if (_.isArray(layoutIds)) {
				var i, layout, layoutCSS = "";
				for (i = 0; i < layoutIds.length; i++) {
					layout = dataSvc.getLayoutById(layoutIds[i]);
					if (layout) {
						if (layoutCSS.length) {
							layoutCSS += " ";
						}
						layoutCSS += layout.css_name;
					} else {
						console.error("Layout lookup failed for:", layoutIds[i]);
					}
				}
				return layoutCSS;
			}
			return layoutIds;
		};

		// Takes an array of styles ids, looks them all up, and returns a concatenated css string
		// Will return (reflect) the passed property if not a valid id
		var resolveStyleCSS = function (styleIds) {
			if (_.isArray(styleIds)) {
				var i, style, styleCSS = "";
				for (i = 0; i < styleIds.length; i++) {
					style = dataSvc.getStyleById(styleIds[i]);
					if (style) {
						if (styleCSS.length) {
							styleCSS += " ";
						}
						styleCSS += style.css_name;
					} else {
						console.error("Style lookup failed for:", styleIds[i]);
					}
				}
				return styleCSS;
			}
			return styleIds;
		};

		// Takes an id for a master asset (video), looks it up, and returns a video definition object
		// Will return (reflect) the passed property if not a valid id
		var resolveMasterAssetVideo = function (masterAssetId) {
			if (isUid(masterAssetId)) {
				var masterAsset = dataSvc.getAssetById(masterAssetId);
				if (masterAsset) {
					// TODO The webm regexp is a bit of a hack, since current API only has one asset url
					// TODO the you_tube_url is a complete and total hack, only because it's not worth going back and modifying existing authoring to support youtube

					return {
						mpeg4: masterAsset.url,
						webm: masterAsset.url.replace(".mp4", ".webm"),
						youtube: masterAsset.you_tube_url
					};
				} else {
					console.error("Master Asset lookup failed for:", masterAssetId);
				}
			}
			return masterAssetId;
		};

		// Takes an id for an asset, looks it up, and returns the asset url
		// Will return (reflect) the passed property if not a valid id
		var resolveAssetUrl = function (assetId) {
			if (isUid(assetId)) {
				var asset = dataSvc.getAssetById(assetId);
				if (asset) {
					return asset.url;
				} else {
					console.error("Asset lookup failed for:", assetId);
				}
			}
			return assetId;
		};

		// Takes an id for an asset, looks it up, and returns the mime type
		// Will return (reflect) the passed property if not a valid id
		var resolveAssetMimeType = function (assetId) {
			if (isUid(assetId)) {
				var asset = dataSvc.getAssetById(assetId);
				if (asset) {
					return asset._type;
				} else {
					console.error("Asset lookup failed for:", assetId);
				}
			}
			return assetId;
		};

		var svc = {};

		// TODO: This is ugly. Need to work on local data, and also no need to transform property names anymore... Now that data contract is consistent we can reference the data objects directly, for better future-compatibility of full-crud.

		svc.createEpisodeModel = function (data) {
			var model = {};

			model.title = data.title;
			model.description = data.description;
			model.category = "Fnord"; // TODO: Implement categories.  Hey I can't see this. How strange.
			model.coverUrl = "/images/coverlogo.png"; // TODO: Implement cover
			model.templateUrl = resolveTemplateUrl(data.template_id) || "templates/episode-default.html";
			model.layout = resolveLayoutCSS(data.layout_id) || "";
			model.styles = resolveStyleCSS(data.style_id) || "";
			model.videos = resolveMasterAssetVideo(data.master_asset_id);

			return model;
		};

		svc.createSceneModel = function (data) {
			var model = {};

			model.type = data.type;
			model.title = data.title;
			if (!model.title) {model.nonNavigable=true;} // HACK
			model.description = data.description;
			model.startTime = data.start_time;
			model.endTime = data.end_time;
			model.templateUrl = resolveTemplateUrl(data.template_id) || "templates/scene-1col.html";
			model.layout = resolveLayoutCSS(data.layout_id) || "";
			model.styles = resolveStyleCSS(data.style_id) || "";
			model.displayTime = Math.floor(data.start_time / 60) + ":" + ("0" + Math.floor(data.start_time) % 60).slice(-2);
			model.isActive = false;
			model.wasActive = false;
			model.items = [];

			if (model.layout.match(/splitOptional/)) {
				model.mainPaneContents = 'required';
				model.altPaneContents = 'optional';
			} else {
				// Default:
				model.mainPaneContents = 'transcript';
				model.altPaneContents = 'transmedia';
			}
			if (model.layout.match(/showCurrent/)) {
				model.showCurrent = true;
			}
			return model;
		};

		svc.createItemModel = function (data) {
			var model = {};

			// base model
			model.type = data.type;
			//model.category = data.category; //TODO: Implement dynamic categories
			model.startTime = data.start_time;
			model.endTime = data.end_time;
			model.layout = resolveLayoutCSS(data.layout_id) || "inline";
			model.styles = resolveStyleCSS(data.style_id) || "";
			model.required = data.required || false;
			model.cosmetic = data.cosmetic || false;
			model.stop = data.stop || false;
			model.displayTime = Math.floor(data.start_time / 60) + ":" + ("0" + Math.floor(data.start_time) % 60).slice(-2);

			// Precalculate whether the item will be inline in a content pane or an overlay/underlay.
			// NOTE/TODO: in producer need to recalculate this if item layout changes!  Does modelFactory handle that for us or do
			// we need to keep track of it ourselves?
			if (model.layout === 'inline' || model.layout.match(/sidebar/) || model.layout.match(/burst/)) {
				model.inContentPane = true;
			}

			// extend base model based on item type
			switch (data.type) {
			case "annotation":
				model.templateUrl = resolveTemplateUrl(data.template_id) || "templates/transcript-default.html";
				model.authorName = data.annotator;
				model.authorThumbSrc = resolveAssetUrl(data.annotation_image_id);
				model.annotation = data.annotation;
				break;

			case "link":
				model.templateUrl = resolveTemplateUrl(data.template_id) || "templates/transmedia-link-default.html";
				model.itemDetailTemplateUrl = "templates/modal-link-default.html"; // hardcoded for now, not sure if we'll want to allow variations here
				model.category = "links"; // TODO: Hardcoded for now. This can go once we implement dynamic categories in the base model construction.
				model.title = data.title;
				model.description = data.description;
				model.thumbSrc = resolveAssetUrl(data.link_image_id);

				// Force wmode=transparent onto youtube embed links, so IE doesn't look so ugly.
				// TODO this should be handled in producer instead of here
				if (data.url.indexOf('youtube.com/embed/') > -1) {
					if (data.url.indexOf('?') === -1) {
						model.source = data.url + "?wmode=transparent";
					} else {
						// remove existing wmode if present first.
						model.source = (data.url.replace(/wmode=[^&]*&?/g,'') + "&wmode=transparent").replace(/&+/g,'&');
					}
				} else {
					model.source = data.url;
				}
				break;

			case "upload":
				var mimeType = data.mimeType || resolveAssetMimeType(data.asset_id); // TODO: data.mimeType will only be truthy in local data. Hopefully this hack can go away with better handling of subtyping. See TODO below.
				if (mimeType.match(/image/)) {
					model.type = "image"; // TODO: Temporary/ugly hack. We could handle subtyping better by creating a subtype or mimetype property and keying off that in the views, instead of changing the actual type on the model, because this is not CRUD friendly.
				}
				model.templateUrl = resolveTemplateUrl(data.template_id) || "templates/transmedia-image-default.html";
				model.itemDetailTemplateUrl = "templates/modal-image-default.html"; // hardcoded for now, not sure if we'll want to allow variations here
				model.title = data.title;
				model.description = data.description;
				model.source = resolveAssetUrl(data.asset_id);
				break;
			}

			return model;
		};

		return svc;
	});

'use strict';

angular.module('com.inthetelling.player')
	.factory('modalMgr', function (videojs, $modal, _) {

		// hold on to a reference of the init overlay so the consumer can
		// create/destroy it asynchronously without needing to keep its own reference
		var initOverlay;

		var svc = {};

		// Method to show the overlay for item detail view
		// itemScope: the scope of the ittItem directive we are creating this overlay for
		svc.createItemDetailOverlay = function (itemScope) {
			// console.log("createItemDetailOverlay:", itemScope.item);

			//HACK
			itemScope.item.isIDevice = (navigator.platform.indexOf('iPad') > -1 || navigator.platform.indexOf('iPhone') > -1 || navigator.platform.indexOf('iPod') > -1);

			itemScope.videoWasPlaying = !(videojs.player.paused()); // So we know whether to start it again when the modal is closed

			videojs.player.pause();

			var resumeVideo = function () {
				if (itemScope.videoWasPlaying) {
					videojs.player.play();
				}
			};

			var modal = $modal.open({
				keyboard: true,
				backdrop: true,
				templateUrl: itemScope.item.itemDetailTemplateUrl,
				windowClass: 'itemDetailModal',
				scope: itemScope
			});

			modal.result.then(function () {
				// if the modal closes 'successfully'
				resumeVideo();
			}, function () {
				// if the modal is 'dismissed'
				resumeVideo();
			});
		};

		/*
	// Method to show the global initialization overlay
	// Does not require a scope or a model
	svc.createInitOverlay = function() {
		console.log("createInitOverlay");
		if (!initOverlay) {
			initOverlay = $modal.open({
				keyboard: false,
				backdrop: 'static',
				templateUrl: 'templates/overlays/init.html'
			});
		}
	};

	// Method to hide the initialization overlay
	svc.destroyInitOverlay = function() {
		console.log("destroyInitOverlay");
		if (initOverlay) {
			initOverlay.close();
			initOverlay = null;
		}
	};
	*/

		return svc;

	})

/*
Below is the part of bootstrap.ui that we were actually using.

TODO: combine modalBackdrop and modalWindow into one directive+template (we'll always have backdrop); move close() function from backdrop directive  to modal
TODO: rip out everything to do with managing multiple modals simultaneously (instead throw an error if try to open two at once)
TODO: was I overhasty in replacing templateUrl with a built-in template below?
	TODO RE templateUrl: To abstract a template into an individual file just add it somewhere to the views directory and the build process will make sure it gets added to $templateCache. Then you can reference its templateUrl path anywhere and it will simply be retrieved (synchronously) from $templateCache.
TODO: (possibly) For items, inject modal into scene node instead of document root, so it can pick up the correct css path? (not sure about this, need to test...)
*/

/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
.factory('$$stackedMap', function () {
	return {
		createNew: function () {
			var stack = [];
			return {
				add: function (key, value) {
					stack.push({
						key: key,
						value: value
					});
				},
				get: function (key) {
					for (var i = 0; i < stack.length; i++) {
						if (key === stack[i].key) {
							return stack[i];
						}
					}
				},
				keys: function () {
					var keys = [];
					for (var i = 0; i < stack.length; i++) {
						keys.push(stack[i].key);
					}
					return keys;
				},
				top: function () {
					return stack[stack.length - 1];
				},
				remove: function (key) {
					var idx = -1;
					for (var i = 0; i < stack.length; i++) {
						if (key === stack[i].key) {
							idx = i;
							break;
						}
					}
					return stack.splice(idx, 1)[0];
				},
				removeTop: function () {
					return stack.splice(stack.length - 1, 1)[0];
				},
				length: function () {
					return stack.length;
				}
			};
		}
	};
})

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
.directive('modalBackdrop', function ($modalStack, $timeout) {
	return {
		restrict: 'EA',
		replace: true,
		template: '<div class="modal-backdrop" x-ng-click="close($event)"></div>',
		link: function (scope, element, attrs) {
			//trigger CSS transitions
			$timeout(function () {
				scope.animate = true;
			});
			scope.close = function (evt) {
				var modal = $modalStack.getTop();
				if (modal && modal.value.backdrop && modal.value.backdrop !== 'static') {
					evt.preventDefault();
					evt.stopPropagation();
					$modalStack.dismiss(modal.key, 'backdrop click');
				}
			};
		}
	};
})

.directive('modalWindow', function ($timeout) {
	return {
		restrict: 'EA',
		scope: {
			index: '@'
		},
		replace: true,
		transclude: true,
		template: '<div class="modal {{windowClass}}" x-ng-transclude></div>',
		link: function (scope, element, attrs) {
			scope.windowClass = attrs.windowClass || '';
			//trigger CSS transitions
			$timeout(function () {
				scope.animate = true;
			});
		}
	};
})

.factory('$modalStack', function ($document, $compile, $rootScope, $$stackedMap) {
	var backdropjqLiteEl, backdropDomEl;
	var backdropScope = $rootScope.$new(true);
	var body = $document.find('body').eq(0);
	var openedWindows = $$stackedMap.createNew();
	var $modalStack = {};

	function backdropIndex() {
		var topBackdropIndex = -1;
		var opened = openedWindows.keys();
		for (var i = 0; i < opened.length; i++) {
			if (openedWindows.get(opened[i]).value.backdrop) {
				topBackdropIndex = i;
			}
		}
		return topBackdropIndex;
	}
	$rootScope.$watch(backdropIndex, function (newBackdropIndex) {
		backdropScope.index = newBackdropIndex;
	});

	function removeModalWindow(modalInstance) {
		var modalWindow = openedWindows.get(modalInstance).value;
		//clean up the stack
		openedWindows.remove(modalInstance);
		//remove window DOM element
		modalWindow.modalDomEl.remove();
		//remove backdrop if no longer needed
		if (backdropIndex() === -1) {
			backdropDomEl.remove();
			backdropDomEl = undefined;
		}
		//destroy scope
		modalWindow.modalScope.$destroy();
	}
	$document.bind('keydown', function (evt) {
		var modal;
		if (evt.which === 27) {
			modal = openedWindows.top();
			if (modal && modal.value.keyboard) {
				$rootScope.$apply(function () {
					$modalStack.dismiss(modal.key);
				});
			}
		}
	});
	$modalStack.open = function (modalInstance, modal) {
		openedWindows.add(modalInstance, {
			deferred: modal.deferred,
			modalScope: modal.scope,
			backdrop: modal.backdrop,
			keyboard: modal.keyboard
		});
		var angularDomEl = angular.element('<div modal-window></div>');
		angularDomEl.attr('window-class', modal.windowClass);
		angularDomEl.attr('index', openedWindows.length() - 1);
		angularDomEl.html(modal.content);
		var modalDomEl = $compile(angularDomEl)(modal.scope);
		openedWindows.top().value.modalDomEl = modalDomEl;
		body.append(modalDomEl);
		if (backdropIndex() >= 0 && !backdropDomEl) {
			backdropjqLiteEl = angular.element('<div modal-backdrop></div>');
			backdropDomEl = $compile(backdropjqLiteEl)(backdropScope);
			body.append(backdropDomEl);
		}
	};
	$modalStack.close = function (modalInstance, result) {
		var modal = openedWindows.get(modalInstance);
		if (modal) {
			modal.value.deferred.resolve(result);
			removeModalWindow(modalInstance);
		}
	};
	$modalStack.dismiss = function (modalInstance, reason) {
		var modalWindow = openedWindows.get(modalInstance).value;
		if (modalWindow) {
			modalWindow.deferred.reject(reason);
			removeModalWindow(modalInstance);
		}
	};
	$modalStack.getTop = function () {
		return openedWindows.top();
	};
	return $modalStack;
})

.provider('$modal', function ($injector) {
	var $modalProvider = {
		options: {
			backdrop: true, //can be also false or 'static'
			keyboard: true
		},
		$get: function ($rootScope, $q, $http, $templateCache, $controller, $modalStack) {
			var $modal = {};

			function getTemplatePromise(options) {
				return options.template ? $q.when(options.template) :
					$http.get(options.templateUrl, {
						cache: $templateCache
					}).then(function (result) {
						return result.data;
					});
			}

			function getResolvePromises(resolves) {
				var promisesArr = [];
				angular.forEach(resolves, function (value, key) {
					if (angular.isFunction(value) || angular.isArray(value)) {
						promisesArr.push($q.when($injector.invoke(value)));
					}
				});
				return promisesArr;
			}
			$modal.open = function (modalOptions) {
				var modalResultDeferred = $q.defer();
				var modalOpenedDeferred = $q.defer();
				//prepare an instance of a modal to be injected into controllers and returned to a caller
				var modalInstance = {
					result: modalResultDeferred.promise,
					opened: modalOpenedDeferred.promise,
					close: function (result) {
						$modalStack.close(modalInstance, result);
					},
					dismiss: function (reason) {
						$modalStack.dismiss(modalInstance, reason);
					}
				};
				//merge and clean up options
				modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
				modalOptions.resolve = modalOptions.resolve || {};
				//verify options
				if (!modalOptions.template && !modalOptions.templateUrl) {
					throw new Error('One of template or templateUrl options is required.');
				}
				var templateAndResolvePromise =
					$q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
				templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {
					var modalScope = (modalOptions.scope || $rootScope).$new();
					modalScope.$close = modalInstance.close;
					modalScope.$dismiss = modalInstance.dismiss;
					var ctrlInstance, ctrlLocals = {};
					var resolveIter = 1;
					//controllers
					if (modalOptions.controller) {
						ctrlLocals.$scope = modalScope;
						ctrlLocals.$modalInstance = modalInstance;
						angular.forEach(modalOptions.resolve, function (value, key) {
							ctrlLocals[key] = tplAndVars[resolveIter++];
						});
						ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
					}
					$modalStack.open(modalInstance, {
						scope: modalScope,
						deferred: modalResultDeferred,
						content: tplAndVars[0],
						backdrop: modalOptions.backdrop,
						keyboard: modalOptions.keyboard,
						windowClass: modalOptions.windowClass
					});
				}, function resolveError(reason) {
					modalResultDeferred.reject(reason);
				});
				templateAndResolvePromise.then(function () {
					modalOpenedDeferred.resolve(true);
				}, function () {
					modalOpenedDeferred.reject(false);
				});
				return modalInstance;
			};
			return $modal;
		}
	};
	return $modalProvider;
});

'use strict';

/*  cuePointScheduler Service
  Manages the conceptual timeline for the episode by publishing key events
  to subscribers. A subscriber must provide a 'span' object which contains
  integer properties 'begin' and 'end'. The service keeps an internal record
  of span states. A span state is active when the playhead is within the begin-end
  range of the span and inactive when it is not. An 'enter' topic will be published
  when the playhead first enters an inactive span, and an 'exit' topic will be
  published when the playhead first exits an active span. The service needs to be
  configured with a timeline provider which keeps the service informed of the playhead
  position, thus synchronizing it with a media item's timeline.
*/
angular.module('com.inthetelling.player')
  .factory('cuePointScheduler', function ($window) {
    var svc = {};

    // Event 'constants' (public)
    svc.ENTER = "enter";
    svc.EXIT = "exit";

    // A collection of spans that have been subscribed with this service
    var subscriptions = [];

    // A dictionary of existing subscription keys, used for speedy reference to
    // check if a subscription exists inside the subscriptions collection
    var subscriptionKeys = {};

    // A unique string to identify the timeline provider
    var providerId;

    // Playhead Position
    var playhead;

    // Flag will be set to true whenever the playhead position changes
    var needScan = false;

    // Reference to the interval timer which kicks off scans
    var scanIntervalId;

    // Generate a key for the inSubscriptions dictionary
    var spanToKey = function (span) {
      return span.begin + '-' + span.end;
    };

    /*  Sets the playhead position. A reference to this function will be given to the registered
    timeline provider and they are expected to call it whenever the playhead position changes.
  */
    var setPlayhead = function (position) {
      //    console.log("setPlayhead("+position+")");
      playhead = position;
      needScan = true;
    };

    /*  Scans the current subscriptions dictionary against the current playhead position,
    and changes span states as needed. Fires the callback for the span whenever there
    is a state change.
    TODO: jsPerf to maximize the speed of the scan. Try things like defining subscriptions[i]
        outside of the loop, case vs. if, lazy truth vs equality checks, nested vs composite ifs,
        needScan condition, etc.
  */
    var scan = function () {
      if (needScan) {
        var i,
          len = subscriptions.length,
          span;
        for (i = 0; i < len; i++) {
          span = subscriptions[i];
          // if the span is active
          if (span.isActive) {
            // and the playhead is outside of the span range
            if (playhead < span.begin || playhead >= span.end) {
              // deactivate the span
              span.isActive = false;
              // and 'publish' EXIT event
              span.callback.call(undefined, {
                begin: span.begin,
                end: span.end
              }, svc.EXIT, playhead);
              // TODO: this needs to be called from the object scope where callback was originally passed in
            }
          }
          // else if the span is inactive
          else if (!span.isActive) {
            // and the playhead is inside of the span range
            if (playhead >= span.begin && playhead < span.end) {
              // activate the span
              span.isActive = true;
              // and 'publish' ENTER event
              span.callback.call(undefined, {
                begin: span.begin,
                end: span.end
              }, svc.ENTER, playhead);
              // TODO: this needs to be called from the object scope where callback was originally passed in
            }
          }
        }
        needScan = false;
      }
    };

    /*  Allow consumer to subscribe to enter/exit events for the given span. Span should be
    an object with 'begin' and 'end' properties as positive integers. If the given span
    already exists the subscription will fail. Callback should be a function that accepts
    a span argument (returning the span object) and an event argument (returning the event string).
    For each span, the callback is fired with an ENTER event when an inactive span becomes active,
    and an EXIT event when an active span becomes inactive.
    Returns true if the subscription was successful and false if the subscription failed.
    TODO: Validate params
   */
    svc.subscribe = function (span, callback) {
      /* validate
    if (!span                       ||
      !callback                     ||
      toString.call(callback) != '[object Function]'  ||
      toString.call(span.begin) != '[object Number]'  ||
      toString.call(span.end) != '[object Number]'  ||
      subscriptionKeys[spanToKey(span)]       ){
      return false;
    }
    */

      subscriptionKeys[spanToKey(span)] = true;

      subscriptions.push({
        begin: span.begin,
        end: span.end,
        callback: callback,
        isActive: false
      });

      return true;
    };

    /*  Unsubscribe the given span. Unsubscribe will fail if the subscription does not exist.
    Returns true if the unsubscribe was successful and false if the unsubscribe failed.
    // TODO: Validate params
  */
    svc.unsubscribe = function (span) {
      /* validate
    if (!span ||
      toString.call(span.begin) != '[object Number]'  ||
      toString.call(span.end) != '[object Number]'  ||
      !subscriptionKeys[spanToKey(span)]        ){
      return false;
    }
    */

      delete subscriptionKeys[spanToKey(span)];

      var i,
        len = subscriptions.length;
      for (i = 0; i < len; i++) {
        if (subscriptions[i].begin === span.begin && subscriptions[i].end === span.end) {
          subscriptions.splice(i, 1); // remove this item
          break;
        }
      }

      return true;
    };

    /*  Allows a timeline provider to be registered with the timeline service. id arg
    is created by the service consumer and will be the unique id by which the provider can
    can be referenced or unregistered later. interval arg is optional and should be a number
    in milliseconds by which scans should occur. If interval is undefined then a default of 1000
    will be used. The scan intervals start as soon as the provider is registered.

    When method is successful it will return a reference to the
    setPlayhead function, which should be called in the service scope via setPlayhead.call().
    If a provider is already registered the method will return false.

    TODO: Invent a secure mechanism by which the setPlayhead function is implicitly tied
    to the providerId (eg: via a dictionary reference). Right now the returned setPlayhead
    function could still be used even after the provider has been unregistered.
    TODO: Validation around id, it must be a primitive that can pass an equality check
    TODO: Validation around interval (sould fall within acceptable range)
  */
    svc.registerProvider = function (id, interval) {
      if (providerId) {
        return false;
      }
      providerId = id;
      scanIntervalId = $window.setInterval(scan, interval || 1000);
      return setPlayhead;
    };

    /*  Unregisters a timeline provider. Returns true if the operation was successful and
    false if the provider was not registered.
  */
    svc.unregisterProvider = function (id) {
      if (providerId !== id) {
        return false;
      }
      providerId = null;
      $window.clearInterval(scanIntervalId);
      return true;
    };

    return svc;
  });

'use strict';

// Expose the global window._ object as an injectable
angular.module('com.inthetelling.player')
	.factory('_', function () {
		return window._;
	});

'use strict';

// Service for initializting and controlling the videojs player
// This service should always be used, as opposed to the global window.videojs reference
angular.module('com.inthetelling.player')
	.factory('videojs', function (config,$rootScope) {

		var svc = {};

		// persistent reference to the instantiated videojs player so we can reference it here and also expose its api publicly
		svc.player = null;

		// Initialize the videojs player. Requires the appropriate videojs markup to already be in the dom
		// We should be passed the id for the main video element to initialize videojs with.
		// Can only initialize once. Will return false if videoJS has already initialized and true if the attempt is successful.
		// Can optionally be passed a callback which will be given a reference to the instantiated player.
		svc.init = function (videodata, callback) {

			// console.log("video service init");
			if (!svc.player) {
				// Instantiate a new videojs player against the provided element id

				var vjsconfig = {
					// customControlsOnMobile was removed from videoJs, but if they ever bring it back we can use it as a better fix
					// than turning off vjs.controls() when something is going to overlap the video
					// (which we need to do on ipad only, because the video controls layer steals all click events within its area
					"controls": true,
					"preload": true,
					"nativeControlsForTouch": false // doesn't seem to do anything?
				};

				// TODO Youtube plugin is buggy on iDevices and IE9.  If we cant fix and can afford the bandwidth, divert those users to S3.
				// SEE ALSO ittVideo.js which needs to perform the same test!
//				if (videodata.youtube && !($rootScope.isIPad || $rootScope.isIPhone)) {
				if (videodata.youtube) {
					vjsconfig.techOrder = ["youtube"];
				} else {
					vjsconfig.techOrder = ["html5", "flash"];
				}
				videojs(config.videoJSElementId, vjsconfig, function () {
					svc.player = this;
					if (callback) {
						callback(svc.player);
					}
				});
				return true;
			}
			return false;
		};

		return svc;

	});

'use strict';

// Expose the global window.config object as an injectable
angular.module('com.inthetelling.player')
	.factory('config', function () {
		var config = window.config;

		// If we're running on an inthetelling.com domain, need to change the API key to match the current subdomain.  This is for authentication, ask bill
		// This will match *all* of them, for example http://www.foo.bar.inthetelling.com would return "www.foo.bar" as the subdomain
		var currentSubdomain = window.location.href.match(/\/\/(.*)\.inthetelling.com/);
		if (currentSubdomain) { // If that didn't match anything we'll just leave the existing apiData url as is.
			// swap the user's subdomain into the apiDataBaseUrl's subdomain (which I'm trying hard not to hardcode here)
			config.apiDataBaseUrl = config.apiDataBaseUrl.replace(/\/\/.*\.inthetelling.com/,"//"+currentSubdomain[1]+".inthetelling.com");
		}
		return config;
	});

'use strict';

// Scene Directive
angular.module('com.inthetelling.player')
	.directive('ittScene', function ($rootScope, $timeout, $window) {
		return {
			restrict: 'A',
			replace: false,
			template: '<div ng-include="scene.templateUrl">Loading Scene...</div>',
			scope: {
				scene: '=ittScene'
			},
			link: function (scope, element, attrs) {
// 				console.log("Scope directive link",scope);

				// Make cosmetic adjustments within the scene based on viewport or video size.
				// TODO: don't use jQuery here if possible?
				// TODO: The special-cases for video and scene-centered templates ought to be tied to those templates specifically
				//       instead of being in the main scene directive
				// HACK: some fragile dependence on template url here, that's pretty lame.  At the very least should use magic classnames instead?
				
				var twiddleSceneLayout = function () {
//				console.log("TwiddleSceneLayout called for ",scope.scene);
					$timeout(function () { // wait for any DOM updates first
						// only trigger on active scenes or on first explore-mode scene (HACK)
						if (scope.scene.isActive || (scope.scene.startTime === 0 && scope.scene.templateUrl.indexOf('scene-explore.html') > -1)) {
// 							console.log("twiddling scene ",scope.scene);
							var videoContainer = element.find('.videoContainer');
//BUG: safari gets height very wrong sometimes, so we're hardcoding the aspect ratio for now;
//								var aspectRatio = videoContainer.width()/videoContainer.height();
								var aspectRatio = 16/9;

							// special case: video mode
							if (scope.scene.templateUrl.indexOf("scene-video.html") > -1) {
								// we want the video to be as wide as possible without overlapping the bottom control bar (so max height is viewport - 45 - 65)  TOOLBAR HEIGHT
								// we dont' want to set the height directly, just the width. So math:
								var maxAllowableHeight = angular.element(window).height()-110;
								if (angular.element(window).width()/maxAllowableHeight > aspectRatio) {
									videoContainer.width(aspectRatio * maxAllowableHeight);
								} else {
									videoContainer.width(angular.element(window).width());
								}
							}
							
							// special case: scene-centered
							if (scope.scene.templateUrl.indexOf("scene-centered.html") > -1) {
								// We effectively want to center a square in the viewport (16:9 video plus allow 16:7 for the transmedia below it)
								// For sanity's sake, leave the column width up to the CSS, only adjust the top padding here.
								// So put the top of the video at (window height - video width)/2
								var pad = (angular.element($window).height() - videoContainer.width()) / 2;
								if (pad < 0) {
									pad = 0;
								}
								element.find('.scene-centered').css("paddingTop", pad);
							}
							
							// Set this explicitly, for safari
							videoContainer.height(videoContainer.width() / aspectRatio);
							
							element.find('.matchVideoHeight:visible').height(videoContainer.height()); // TODO check if this works with multiple .matchVideoHeight elements in the scene
							element.find('.stretchToViewportBottom:visible').each(function () {
								$(this).css("min-height", (angular.element($window).height() - this.offsetTop - 45)); // HACK: 45 is /* TOOLBAR HEIGHT */ 
							});
						}
					},0);

				};
				
				// iframes on ipads plus window.resize watchers == crash.
				if ($rootScope.isFramed && ($rootScope.isIPad || $rootScope.isIPhone)) {
					scope.$watch(function() {return scope.IOSFramewidth},twiddleSceneLayout);
				} else {
					angular.element($window).bind('resize', twiddleSceneLayout);
				}

				scope.$watch('scene.isActive', function (newVal, oldVal) {
					if (newVal) {
// 						console.log("SCENE ENTERING", scope.scene);
						twiddleSceneLayout();
						$timeout(function() {
							$rootScope.$emit('magnet.changeMagnet',element.find('.videoContainer'));
						},0);
					} else if (oldVal) {
//						console.log("SCENE EXITING",scope.scene);
					}
				});

				$rootScope.$on('toolbar.changedSceneTemplate', function() {
					twiddleSceneLayout();
					if (scope.scene.isActive) {
						$timeout(function() {
//						console.log("Changed scene template, updating magnet for scene");
							$rootScope.$emit('magnet.changeMagnet',element.find('.videoContainer'));
						},0);
					}
				});

			}
		};
	});

'use strict';

// "Transmedia" Item Directive
angular.module('com.inthetelling.player')
	.directive('ittItem', function (modalMgr) {
		return {
			restrict: 'A',
			replace: false,
			template: '<div ng-include="item.templateUrl">Loading Item...</div>',
			scope: {
				item: '=ittItem'
			},
			link: function (scope, element, attrs) {
				// TODO this whole force-template thing is a total hack.  Should be handled at the scene level instead of here.
				// Most of this is overriding things back to default in the explore mode; that may wind up being better as a whole different
				// item directive.   (video mode uses it too, but much less complicated-ly)
				
				// check for forceTemplate attribute on the item ng-repeat.  If present, stash the real templateUrl in origTemplateUrl,
				// and set a new templateUrl value for this scene only.
				if (attrs.forceItemTemplate) {
					scope.item.origTemplateUrl = scope.item.templateUrl;
					if (scope.item.type === "annotation") {
						if (attrs.forceItemTemplate === "default" && scope.item.templateUrl.indexOf("templates/text-") > -1) {
							// leave headers and pullquotes alone in explore mode
						} else {
							scope.item.templateUrl="templates/transcript-"+attrs.forceItemTemplate+".html";
						}
					} else if (scope.item.type === "upload" || scope.item.type === "image") { // TODO "image" is probably an artifact of bad test data; need to check API to make sure that can safely be removed
						scope.item.templateUrl="templates/transmedia-image-"+attrs.forceItemTemplate+".html";
					} else if (scope.item.type === "link") {
						// HACK exceptions and special cases galore
						if (scope.item.templateUrl !== "templates/transmedia-link-noembed.html") {
							scope.item.templateUrl="templates/transmedia-link-"+attrs.forceItemTemplate+".html";
						}
					} else {
						console.warn("PROBABLE ERROR: unknown item type ",scope.item);
					}
					// Stash and disable the styles and layout, too. (TODO: in future may want to allow some or all of these after all...)
					scope.item.origLayout = scope.item.layout;
					scope.item.origStyles = scope.item.styles;
					scope.item.layout = '';
					scope.item.styles = '';
				} else {
					// no forceTemplate, so revert to the original (if there is one!)
					if (scope.item.origTemplateUrl) {
						scope.item.templateUrl = scope.item.origTemplateUrl;
						scope.item.layout = scope.item.origLayout;
						scope.item.styles = scope.item.origStyles;
					}
				}

				scope.toggleDetailView = function () {
					if (scope.item.showInlineDetail) {
						// if inline detail view is visible, close it. (If a modal is visible, this is inaccessible anyway, so no need to handle that case.)
						scope.item.showInlineDetail = false;
					} else if (element.closest('.content').width() > 500) {
						// otherwise show detail inline if there's room for it:
						scope.item.showInlineDetail = !scope.item.showInlineDetail;
					} else {
						// otherwise pop a modal
						modalMgr.createItemDetailOverlay(scope);
					}
				};

			},
			controller: "ItemController"
		};
	});

'use strict';

// Video.js Wrapper Directive
// - can only declare one of these for an episode
// - should never be reparented or removed from the dom (use ittMagnet directives instead)
angular.module('com.inthetelling.player')
	.directive('ittVideo', function (cuePointScheduler, videojs, $timeout, config, $rootScope) {
		return {
			restrict: 'A',
			replace: false,
			template: '<div class="video"></div>',
			link: function (scope, element, attrs) {
//				console.log("ITT-VIDEO LINKING FUNCTION: [scope:", scope, "]");

				// Create the DOM node contents required by videojs.
				// (Injecting this manually because including it in the template causes lots of bogus warnings
				// and a vjs error that I don't want to track down)

				element.find('.video').html(function () {
					var node = '<video id="' + config.videoJSElementId + '" class="video-js vjs-story-skin" poster="' + scope.episode.coverUrl + '">';
					// For now, youtube overrides others if present.
					// Except for iDevices, for which the youtube plugin is buggy. TODO fix the plugin. For now divert to mp4 version
//					if (scope.episode.videos.youtube && !($rootScope.isIPad || $rootScope.isIPhone)) {
					if (scope.episode.videos.youtube) {
						node += '<source type="video/youtube" src="' + scope.episode.videos.youtube + '" />';
					} else {
						node += '<source type="video/mp4" src="' + scope.episode.videos.mpeg4 + '" />';
						node += '<source type="video/webm" src="' + scope.episode.videos.webm + '" />';
					}
					node += ' </video>';
					return node;
				});

				// Register videojs as the provider for the cuePointScheduler service.
				// We are only using videoJSElementId as a UID here for convenience. cuePointScheduler has no DOM awareness.
				scope.setPlayhead = cuePointScheduler.registerProvider(config.videoJSElementId, config.cuePointScanInterval);

				// Initialize videojs via the videojs service
				// (This is NOT calling videojs directly; extra layer of indirection through services/video.js!)  (TODO: why?)
				videojs.init(scope.episode.videos, function (player) {
//					console.log("videojs init");

					// Catch the first play. VJS's "firstplay" event is buggy, we'll just use 'play' and catch duplicates.
					// (would just wipe the event instead, but vjs doesn't support namespaced events either...)
					player.on("play",function() {
//						console.log("player play");
						if (!player.hasPlayed) {
							player.hasPlayed= true;
							$rootScope.$emit("toolbar.videoFirstPlay");

							// register a listener on the instantiated player to inform the cuePointScheduler
							// service whenever the playhead position changes.
							player.on("timeupdate", function () {
								//console.log("$$ timeupdate &&", player.currentTime());
								scope.setPlayhead(player.currentTime());
							});
						}
					});


					// Wait until we know the player duration, then set the scene markers (and kill the $watch)
					// TODO if we can get the video duration in the json we'll be able to init this directly
					var durationWatcher = scope.$watch(function () {
						return player.duration();
					}, function (newVal, oldVal) {
						if (newVal !== 0) {
							// We now know the video duration, so can position the markers:
							durationWatcher(); // removes the watcher
							//Feed data into videojs.markers plugin:
							var markerData = {
								setting: {},
								marker_breaks: [],
								marker_text: []
							};
							for (var i = 0; i < scope.scenes.length; i++) {
								if (scope.scenes[i].title) {
									markerData.marker_breaks.push(scope.scenes[i].startTime);
									markerData.marker_text.push(scope.scenes[i].title);
								}
							}

							player.markers(markerData); // sets up the plugin
							player.trigger("loadedmetadata"); //signals the plugin to do its thing (the event doesn't fire reliably on its own)
						}
					});
					/* Done setting scene markers. */
				});

			}
		};
	});

'use strict';

// ittMagnetized elements respond to ittMagnet events and reposition themselves to match
// the $rootScope.activeMagnet node.

// (Was using a directive for magnets, but that was overcomplicated. A global makes sense here
// because we really do only ever want one magnet active at a time.)

angular.module('com.inthetelling.player')
	.directive('ittMagnetized', function ($rootScope, $timeout) {
		return {
			restrict: 'A',
			replace: true,
			scope: true,
			link: function (scope, element) {
/*
				// resize/reposition ourselves to the passed magnet's element.
				scope.reposition = function (animate) {
// 							console.log("ittMagnetized", element);
						if (!scope.magnet) {
							// no magnet set, so don't do anything
							return;
						}
// 					console.log("ittMagnetized triggered, attracting ",element," to ",scope.magnet, " animation is ",animate);


// Safari gets the wrong height sometimes (TODO figure out why? it's not a magnet-is-not-visible problem, because the width is correct...)
// hardcoding aspect ratio for now, therefore.  SEE ALSO ittScene
					var aspectRatio = 16/9;
					
					// if videoContainer is position:fixed, video should be too
					element.css("position", (scope.magnet.css("position") === "fixed") ? "fixed" : "absolute" );

// TODO temporarily disabling this animation to see if it lets us run acceptably on older devices (iPad2 was freaking out)
					if (false && animate && $(element).is(':visible')) {
						$(element).stop(true).animate({
							top: scope.magnet.offset().top - $(window).scrollTop(),
							left: scope.magnet.offset().left,
							width: scope.magnet.width(),
							height: Math.ceil(scope.magnet.width() / aspectRatio)
						},500);
					} else {
						element.offset(scope.magnet.offset());
						element.width(scope.magnet.width());
						element.height(Math.ceil(scope.magnet.width() / aspectRatio));
					}
				};
				
				$rootScope.$on('magnet.changeMagnet', function(evt,magnet) {
					scope.magnet = magnet;
					scope.reposition(true);
				});

				// reposition ourselves on magnet events sent from the toolbar / player chrome
				var watcherOne = $rootScope.$on('magnet.reposition', function() {
					scope.reposition(true);
				});
				var watcherTwo = $rootScope.$on('magnet.repositionImmediately', function() {
					scope.reposition(false);
				});

				// cleanup watchers on destroy
				scope.$on('$destroy', function () {
					watcherOne();
					watcherTwo();
				});
			}
*/			
			
		};
	});

'use strict';


// This is turning into the player chrome rather than just the toolbar. TODO name change or refactor you be the judge

angular.module('com.inthetelling.player')
	.directive('ittToolbar', function ($timeout, $rootScope, videojs, $window,$location) {
		return {
			restrict: 'A',
			replace: true,
			scope: true,
			templateUrl: 'templates/toolbar/toolbar.html',
			link: function (scope, element, attrs, controller) {
				// scope is a child scope that inherits from EpisodeController scope
				// thus anything that is added to this scope here is private to the directive,
				// but everything on parent scope is still accessible.
				
				
				
				
				
				// Nav and Search:
				scope.show = {
					navigationPanel: false,
					searchPanel: false,
					searchPanelInternals: false,
					introPanel: true,
					playerPanel: false
				};

				// Initial magnet should be the one in the landing page
				$timeout(function() {
					$rootScope.$emit('magnet.changeMagnet',element.find('.videoContainer'));
				},0);
				
				
				
								// ipad crashes on window resize events inside an iframe.  So don't do that.
				if ($rootScope.isFramed && ($rootScope.isIPad || $rootScope.isIPhone)) {
					scope.$watch(function() {return scope.IOSFramewidth},function() {
						$rootScope.$emit('magnet.repositionImmediately');
					});
				} else {
					angular.element($window).bind('resize', function() {
						$rootScope.$emit('magnet.repositionImmediately');
					});
				}

				
// Bad idea. Also not necessary.
// 				scope.bruteForceMagnetism = $interval(function() {
// 						$rootScope.$emit('magnet.reposition');
// 				}, 1000,0,false);

				
				// global to allow scenes to easily watch for window resize.
				// (Not actually a performance improvement over letting each scene bind directly, so disabling for now, but keeping it for future How Did I Do That reference)
				/*
				angular.element($window).bind('resize',function() {
					$rootScope.windowWidth = $window.outerWidth; 
					$rootScope.$apply('windowWidth');
				});
				*/
				
				
				/* Handler for toolbar buttons to change scene templates. */
				scope.setSceneTemplate = function (newTemplate) {
					//			console.log("setSceneTemplate " + newTemplate);
				
					scope.currentSceneTemplate = newTemplate;
					// set all scenes to use newTemplate
					for (var i = 0; i < scope.scenes.length; i++) {
						var thisScene = scope.scenes[i];
						if (newTemplate) {
							if (thisScene.origTemplateUrl === undefined) {
								thisScene.origTemplateUrl = thisScene.templateUrl; // so we can revert to it later
							}
							thisScene.templateUrl = "templates/scene-" + newTemplate + ".html"; // hardcoded for now
						} else {
							if (thisScene.origTemplateUrl) { // if this is undefined, we've never left directed view so don't need to do anything here
								thisScene.templateUrl = thisScene.origTemplateUrl;
							}
						}
					}
					// TODO: set button states immediately since scene redraw takes a while; need to give users feedback that it's working
					$rootScope.$emit('toolbar.changedSceneTemplate');
				};
				
				/* detect which view we're in */
				/* this is a bizarre syntax but seems to be how it's supposed to work... */
				scope.currentSceneTemplateIs = function (compare) {
					return scope.currentSceneTemplate === compare;
				};
				
				/* The "view / watch" button toggles between explore and directed modes: */
				scope.toggleSceneTemplate = function () {
					if (scope.currentSceneTemplate === 'explore') {
						scope.setSceneTemplate('');
					} else {
						scope.setSceneTemplate('explore');
					}
				};
				
				scope.mainframeescape = function() {
					videojs.player.pause();
					window.open($location.absUrl()).focus();
				};
				
				scope.showNavigationPanel = function () {
					videojs.player.pause();
					videojs.player.controls(false); // TODO: do this on iPad only
					scope.show.navigationPanel = true;
				};
				
				scope.showSearchPanel = function () {
					videojs.player.pause();
					videojs.player.controls(false); // TODO: do this on iPad only
				
					scope.show.searchPanel = true;
					// Wait a tick before building the search panel internals. (Possibly unnecessary, but just in case...)
					$timeout(function () {
						scope.show.searchPanelInternals = true;
					}, 0);
				};
				
				scope.toggleSearchPanel = function () {
					if (scope.show.searchPanel) {
						scope.hidePanels();
					} else {
						scope.showSearchPanel();
						document.getElementById('searchtext').focus(); // TODO BUG not working in Safari
					}
				};
				
				scope.showSceneMenu = function () {
					if (scope.show.navigationPanel) {
						scope.hidePanels();
					} else {
						scope.showNavigationPanel();
					}
				};

				// triggers vjs footer controls to appear
				scope.showVideoControls = function () {
					if (videojs.player) { // in case video hasn't inited yet
						videojs.player.userActive(true);
					}
				};
				
				scope.hidePanels = function () {
					// (Same trigger to dismiss either panel; fine since only one can be visible at a time anyway)
					scope.show.navigationPanel = false;
					scope.show.searchPanel = false;
					scope.searchText = '';
					videojs.player.controls(true); // TODO: do this on iPad only
					// For now, don't set searchPanelInternals to false here; once it's built leave it in place to maintain state.
					// TODO if this causes memory problems on old devices we can change this, but I think rendering time is more our bottleneck than low memory conditions.
				};
				
				scope.gotoTime = function (t) {
					videojs.player.currentTime(t + 0.001); // fudge: add a bit to ensure that we're inside the next scene's range
				};
				
				// When user first clicks video, show the toolbar chrome and hide the landing screen
				scope.firstPlayWatcher = $rootScope.$on('toolbar.videoFirstPlay', function () {
					// Move our custom controls into the vjs control bar.  TODO fix jquery hackage
					$('.injectedvideocontrols').appendTo($('.vjs-control-bar')).show();
				
					// Hide the intro; show the regular controls
					scope.show.introPanel = false;
					scope.show.playerPanel = true;
					$rootScope.$emit('toolbar.changedSceneTemplate'); // force twiddleSceneLayout
				
					scope.firstPlayWatcher(); // stop listening for this event
				
					// For next/prev scene buttons:
					scope.curSceneWatcher = scope.$watch(function () {
						// step through episode.scenes, return the last one whose start time is before the current time
						var now = videojs.player.currentTime();
						for (var i = 0; i < scope.scenes.length; i++) {
							if (scope.scenes[i].startTime > now) {
								return scope.scenes[i - 1]; //break loop on first match
							}
						}
						return scope.scenes[scope.scenes.length - 1]; // no match means we are in the last scene
					}, function (newVal, oldVal) {
						scope.curScene = newVal;
					});
				
				});
				
				
				// HACK HACK such an ungodly HACK.
				// iDevices combined with the youtube player need some special handling as far as event timing goes; normally the firstPlayWatcher
				// fires immediately when the user hits "play", but on iDevices there's a potentially long delay while the video starts buffering after first
				// user interaction. Ugly. So we're watching for a different event that on the iPad fires earlier than the 'play' event,
				// and use it to trigger the videoFirstPlay event instead.
				/*
				scope.firstPlayWatcherForIDevicesWhenWeAreUsingYoutube = scope.$watch(
					function () {
						if (videojs.player) {
							return videojs.player.durationchanged;
						}
					},
					function (durationchanged) {
						if (durationchanged) {
							$rootScope.$emit('toolbar.videoFirstPlay');
							scope.firstPlayWatcherForIDevicesWhenWeAreUsingYoutube(); // stop watching
						}
					}
				);
				*/
						
			},
			controller: "ToolbarController"
		};
	});

'use strict';

angular.module('com.inthetelling.player')
	.directive('ittContentPane', function ($filter) {
		return {
			restrict: 'A',
			replace: false,
			scope: true,
			templateUrl: 'templates/contentpane.html',
			link: function (scope, element, attrs) {
				// scope is a child scope that inherits from EpisodeController scope
				// thus anything that is added to this scope here is private to the directive,
				// but everything on parent scope is still accessible.

				// TODO / NOTE   Not sure if attributes is the best way to communicate from the template to the directive?  Works fine but maybe there's a smarter way
				/* Recognized attributes (all optional):
					- data-pane ("main" or "alt", defaults to "main")
					- data-no-sidebars (bool)
					- data-show-current (bool)
					- data-content (any value recognized by the "layout" filter). Defaults to "content". TODO: would it be better to remove the layout filter and instead filter the items here inside the directive?
					- data-force-item-template (See item directive; this just passes it through)
			*/

				scope.pane = attrs.pane || "main";

				// which content to include in pane:
				scope.contentLayout = attrs.content || "content";
				scope.itemlist = $filter('layout')(scope.scene.items, scope.contentLayout);

				// Whether to show only current items or all items:
				scope.showCurrent = (scope.scene.showCurrent || attrs.showCurrent);

				// Special case: explore view is never showCurrent:
				// TODO make this dependent on something less fragile than the template url
				if (scope.scene.templateUrl === "templates/scene-explore.html") {
					scope.showCurrent = false;
				}

				// Whether to force a particular item template:
				scope.forceItemTemplate = attrs.forceItemTemplate;

				// Sidebars:
				var checkForSidebars = function () {
					//				console.log("contentpane checkForSidebars");
					if (attrs.noSidebars) {
						scope.noSidebars = true;
						return;
					}
					// scan through the items to see if sidebars are needed in this content pane:
					for (var i = 0; i < scope.itemlist.length; i++) {
						var layout = scope.itemlist[i].layout;
						if (layout === "burst") {
							scope.hasLeftSidebar = true;
							scope.hasRightSidebar = true;
						} else if (layout === "sidebarL" || layout === "burstL") {
							scope.hasLeftSidebar = true;
						} else if (layout === "sidebarR" || layout === "burstR") {
							scope.hasRightSidebar = true;
						}
					}
				};
				//checkForSidebars();  // This may be redundant, as the $watch seems to fire immediately anyway, but it feels unsafe to leave it out
				// On second thought: it's firing anyway.

				// Responsive pane width:
				scope.$watch(function () {
					return element.width();
				}, function (newValue, oldValue) {
					if (newValue > 0 && newValue < 450) {
						scope.noSidebars = true;
						scope.hasLeftSidebar = false;
						scope.hasRightSidebar = false;
					} else {
						checkForSidebars();
					}
				}, true);
			}
		};
	});

'use strict';

/*
	Filters a collection of item models by their type property. Should be provided an map of allowed types. Types may be omitted.
	Usage example, filtering an items list to only links and images:
	<div ng-repeat="item in scene.items | types:{link: true, image: true}]"></div>
*/
angular.module('com.inthetelling.player')
	.filter('type', function () {
		return function (items, allowedTypes) {
			if (allowedTypes) {
				var itemsIn = [],
					i;
				for (i = 0; i < items.length; i++) {
					if (allowedTypes[items[i].type]) {
						itemsIn.push(items[i]);
					}
				}
				return itemsIn;
			}
			return [];
		};
	});

'use strict';

/*
	Filters the item list based on where they need to appear.

	layout = any valid scene.layout, or one of the following:
		required   (returns annotation and required transmedia)
		optional   (returns non-required transmedia)
		content    (returns all annotation and transmedia)
		transcript (returns all annotation items)
		transmedia (returns all except annotation items)
*/
angular.module('com.inthetelling.player')
	.filter('layout', function () {

		return function (items, layout) {
			if (!items || !layout) {
				return [];
			}
			var filteredItems = [],
				i;
			if (layout === 'required' || layout === 'optional' || layout === 'transcript' || layout === 'transmedia' || layout === 'content') {
				// return items for one of the five types of content pane.
				// We can ignore any items here for which item.inContentPane is false.
				for (i = 0; i < items.length; i++) {
					if (items[i].inContentPane) {
						if (layout === 'transcript') {
							if (items[i].type === 'annotation') {
								filteredItems.push(items[i]);
							}
						} else if (layout === 'transmedia') {
							if (items[i].type !== 'annotation') {
								filteredItems.push(items[i]);
							}
						} else if (layout === 'required') {
							if (items[i].type === 'annotation' || items[i].required) {
								filteredItems.push(items[i]);
							}
						} else if (layout === 'optional') {
							if (items[i].type !== 'annotation' && !(items[i].required)) {
								filteredItems.push(items[i]);
							}
						} else { // "content", so return everything:
							filteredItems.push(items[i]);
						}
					}
				}
			} else {
				// match only the specific layout input
				for (i = 0; i < items.length; i++) {
					if (items[i].layout === layout) {
						filteredItems.push(items[i]);
					}
				}
			}
			return filteredItems;
		};
	});

'use strict';

/*
	Filter for content items, Used in contentpane.html
	if showCurrent is true, returns only items for which isActive is true.
	Otherwise just returns the entire list.

*/
angular.module('com.inthetelling.player')
	.filter('itemList', function () {
		return function (items, showCurrent) {
			if (showCurrent) {
				var filteredItems = [],
					i;
				for (i = 0; i < items.length; i++) {
					if (items[i].isActive) {
						filteredItems.push(items[i]);
					}
				}
				return filteredItems;
			} else {
				return items;
			}

		};
	});

'use strict';

/* This is basically just the ui-utils highlight filter, except that I'm too lazy to figure out how to inject a different module into the app right now. */
/* I'll just think of it as being frugal. */

angular.module('com.inthetelling.player')
	.filter('highlight', function ($sce) {
		return function (text, search) {
			if (search || angular.isNumber(search)) {
				return $sce.trustAsHtml(text.toString().replace(new RegExp(search.toString(), 'gi'), '<span class="ui-match">$&</span>'));
			} else {
				return text;
			}
		};
	}
);

'use strict';

/*
	For use in video mode: returns only non-cosmetic, current transcript items
*/
angular.module('com.inthetelling.player')
	.filter('transcript', function () {
		return function (items) {
			var filteredItems = [];
			for (var i=0; i<items.length;i++) {
				if (
					items[i].type === 'annotation' &&
					items[i].isActive &&
					!(items[i].cosmetic) &&
					(items[i].templateUrl.indexOf('/transcript-')>-1)
				) {
					filteredItems.push(items[i]);
				}
			}
			return filteredItems;
		};
	});
